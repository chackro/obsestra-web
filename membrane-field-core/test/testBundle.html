<!DOCTYPE html>
<html lang="en">

<head>
    <script src="../coi-serviceworker.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIEN/FIELD Viewer</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet"
        crossorigin>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            cursor: none;
        }

        canvas:active {
            cursor: none;
        }

        #controls {
            width: 300px;
            background: #12121a;
            padding: 16px;
            overflow-y: auto;
            border-left: 1px solid #2a2a3e;
            display: none;
            /* Hidden - functions called internally */
        }

        #btn-avanzar {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.7);
            color: #000;
            border: none;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
        }

        #btn-avanzar:hover {
            background: rgba(255, 255, 255, 0.9);
        }

        #btn-skip {
            display: none; /* Hidden for public deployment */
        }

        #bottom-action-bar {
            display: none; /* Hidden for public deployment */
        }

        #intro-text {
            position: fixed;
            top: 50%;
            left: 75%;
            transform: translateX(-50%);
            color: #fff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(10px, 1.4vw, 15px);
            font-weight: 400;
            max-width: 1200px;
            text-align: left;
            line-height: 1.6;
            z-index: 999;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(0, 0, 0, 0.6);
            display: none;
        }

        #intro-text.centered {
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        #intro-text .dimension-name {
            font-size: clamp(12px, 1.5vw, 17px);
            font-weight: 500;
        }

        /* Dimension stack - fixed positions so items don't shift */
        #dim-stack {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }

        .dimension-box {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 34px;
            font-weight: 500;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(0, 0, 0, 0.6);
            display: none;
            white-space: nowrap;
        }

        .dim-group {
            top: 28%;
        }

        #dim-2 {
            top: 48%;
        }

        #dim-3 {
            top: 68%;
        }

        #dim-stack.shifted .dimension-box,
        #dim-stack.shifted .dim-group {
            left: 75%;
            transform: none;
        }

        .dimension-box.visible {
            display: block;
        }

        .dimension-box.faded {
            opacity: 0;
        }

        .dim-group {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        #dim-stack.shifted .dim-group {
            transform: none;
        }

        .dim-group #dim-1 {
            position: static;
            transform: none;
        }

        .dimension-desc {
            color: #fff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 28px;
            font-weight: 400;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(0, 0, 0, 0.6);
            display: none;
            margin-top: 20px;
            white-space: nowrap;
        }

        .dimension-desc.visible {
            display: block;
        }

        .dimension-desc .bold {
            font-weight: 600;
        }

        #telemetry-overlay {
            position: fixed;
            top: 2vh;
            left: 1.5vw;
            text-align: left;
            color: #fff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(10px, 1.4vw, 16px);
            line-height: 1.15;
            z-index: 999;
            pointer-events: none;
            display: none;
        }

        .telemetry-line {
            margin-bottom: 2px;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.95), 0 0 12px rgba(0, 0, 0, 0.8);
        }

        /* Tree-style telemetry indentation */
        .telemetry-line.indent-1 {
            padding-left: 1.5em;
        }

        .telemetry-line.indent-2 {
            padding-left: 3em;
        }

        .telemetry-line.tree::before {
            content: '├ ';
            color: #666;
        }

        .telemetry-line.tree-last::before {
            content: '└ ';
            color: #666;
        }

        .telemetry-line.tree-cont::before {
            content: '│ ';
            color: #666;
        }

        /* Telemetry color sync with particle modes */
        /* Colors only apply when container has the matching mode class */
        #telemetry-overlay.state-mode .color-state {
            color: #ff8000;
            /* Orange - restricted particles */
        }

        #telemetry-overlay.source-mode .color-source-mty {
            color: #ff3333;
            /* Red - West corridor */
        }

        #telemetry-overlay.source-mode .color-source-vic {
            color: #3366ff;
            /* Blue - East corridor */
        }

        #telemetry-overlay.source-mode .color-source-local {
            color: #33cc33;
            /* Green - Industrial */
        }

        /* Scenario comparison overlay - positioned below clock, above metrics */
        #scenario-overlay {
            position: fixed;
            top: 120px;
            right: 24px;
            z-index: 1001;
            pointer-events: none;
            text-align: right;
        }

        #scenario-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(8px, 1.1vw, 12px);
            font-weight: 700;
            color: #fa0;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.9);
            display: none;
        }

        #scenario-intervention {
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(6px, 0.7vw, 8px);
            font-weight: 400;
            color: #aaa;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
            margin-top: 4px;
            display: none;
        }

        #montage-overlay {
            position: fixed;
            top: 5vh;
            right: 1.5vw;
            text-align: right;
            z-index: 1000;
            pointer-events: none;
        }

        #montage-day {
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(10px, 1.2vw, 14px);
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.9);
            display: none;
        }

        #montage-clock {
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(14px, 2vw, 24px);
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.9);
            display: none;
        }

        /* Macro layer month clock - shows month during alienObserver */
        #macro-month-clock {
            position: fixed;
            top: 2vh;
            right: 1.5vw;
            font-family: 'IBM Plex Mono', monospace;
            font-size: clamp(10px, 1.4vw, 16px);
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            pointer-events: none;
            display: none;
        }

        /* Replay status banner - top of screen */
        #replay-lockout-banner {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 16px;
            font-weight: 700;
            color: #ffcc00;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 24px;
            border: 1px solid #ffcc00;
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.5);
            z-index: 2000;
            display: none;
            letter-spacing: 2px;
        }

        #controls-lockout-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1500;
            display: none;
            pointer-events: all;
            cursor: not-allowed;
        }

        body.replay-locked #controls-panel,
        body.replay-locked #director-panel {
            opacity: 0.4;
            pointer-events: none;
        }

        /* Replay mode indicator (kinematic replay active) */
        #replay-mode-indicator {
            position: fixed;
            bottom: 80px;
            left: 24px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            color: #00ffcc;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border: 1px solid #00ffcc;
            letter-spacing: 1px;
            z-index: 1000;
            display: none;
        }

        #scenario-metrics {
            position: fixed;
            top: 160px;
            right: 24px;
            z-index: 1000;
            pointer-events: none;
            font-family: 'IBM Plex Mono', monospace;
            text-align: right;
            display: none;
        }

        .metric-line {
            display: flex;
            justify-content: space-between;
            width: 420px;
            margin-bottom: 6px;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
        }

        .metric-label {
            font-size: 14px;
            font-weight: 400;
            color: #ddd;
        }

        .metric-value {
            font-size: 14px;
            font-weight: 700;
            color: #ddd;
        }

        .metric-line.breakdown {
            padding-left: 16px;
        }

        .metric-line.breakdown .metric-label::before {
            content: '├ ';
            color: #666;
        }

        .metric-line.breakdown.last .metric-label::before {
            content: '└ ';
        }

        .metric-line.delta {
            margin-top: 12px;
        }

        .metric-line.delta .metric-value {
            font-size: 24px;
            color: #0ff;
        }

        #comparison-table {
            position: fixed;
            bottom: 40px;
            right: 30px;
            z-index: 1001;
            pointer-events: none;
            font-family: 'IBM Plex Mono', monospace;
            background: rgba(0, 0, 0, 0.90);
            padding: 15px 30px;
            border: 1px solid #333;
            display: none;
            transform: scale(0.5);
            transform-origin: bottom right;
        }

        .tier-label {
            color: #666;
            font-size: 23px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            margin-top: 24px;
        }

        .tier-label:first-child {
            margin-top: 0;
        }

        .table-header {
            display: flex;
            padding-bottom: 9px;
            margin-bottom: 9px;
            border-bottom: 1px solid #333;
            color: #666;
            font-size: 24px;
        }

        .table-header span {
            text-align: right;
        }

        .table-header span:first-child {
            width: 570px;
            text-align: left;
        }

        .table-header span:nth-child(2) {
            width: 230px;
        }

        .table-header span:nth-child(3) {
            width: 260px;
        }

        /* Tier 2 only has 3 cols now (Espera patios commented out) */
        .table-header span:nth-child(4) {
            width: 260px;
        }

        .table-row {
            display: flex;
            padding: 8px 0;
            color: #ccc;
            font-size: 27px;
        }

        .table-row span {
            text-align: right;
        }

        .table-row span:first-child {
            width: 570px;
            text-align: left;
            font-weight: 400;
        }

        .table-row span:nth-child(2) {
            width: 230px;
            font-weight: 600;
        }

        .table-row span:nth-child(3) {
            width: 260px;
        }

        /* Tier 2 only has 3 cols now (Espera patios commented out) */
        .table-row span:nth-child(4) {
            width: 260px;
        }

        .table-row.baseline {
            color: #888;
        }

        .table-row .delta {
            font-size: 23px;
            color: #0aa;
            margin-left: 6px;
        }

        .table-row .delta.negative {
            color: #0c6;
        }

        .table-row .delta.positive {
            color: #c66;
        }

        /* Live logs panel - terminal style */
        #live-logs {
            position: fixed;
            top: 0;
            left: 0;
            width: 33.333vw;
            height: 100vh;
            background: rgba(10, 10, 15, 0.95);
            border-right: 1px solid #222;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            color: #888;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        #live-logs-content {
            padding: 16px 20px;
            height: 100%;
            overflow-y: auto;
            line-height: 1.5;
        }

        #live-logs-content .log-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #live-logs-content .log-ts {
            color: #555;
        }

        #live-logs-content .log-msg {
            color: #aaa;
        }

        #director-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 800px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 24px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            z-index: 2000;
            border-right: 2px solid #444;
            display: none;
            overflow-y: auto;
        }

        #step-stack {
            background: #111;
            border: 1px solid #333;
            margin: 12px 0;
            max-height: 50vh;
            overflow-y: auto;
        }

        .step-item {
            display: flex;
            align-items: center;
            padding: 12px 12px;
            border-bottom: 1px solid #222;
            cursor: grab;
            font-size: 14px;
        }

        .step-item:hover {
            background: #1a1a2e;
        }

        .step-item.current {
            background: #0a3a0a;
            border-left: 3px solid #0f0;
        }

        .step-item.dragging {
            opacity: 0.5;
        }

        .step-item .step-num {
            color: #666;
            margin-right: 8px;
            min-width: 20px;
        }

        .step-item .step-type {
            color: #88f;
            margin-right: 8px;
            min-width: 60px;
        }

        .step-item .step-desc {
            color: #aaa;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .step-item .step-actions {
            display: flex;
            gap: 4px;
        }

        .step-item .step-btn {
            background: #333;
            border: none;
            color: #888;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
        }

        .step-item .step-btn:hover {
            background: #444;
            color: #fff;
        }

        .step-item .step-btn.play {
            color: #0f0;
        }

        .step-item .step-btn.delete {
            color: #f44;
        }

        #add-step-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 16px 0;
        }

        #add-step-menu button {
            font-size: 13px;
            padding: 8px 14px;
        }

        #director-panel button {
            font-size: 13px;
            padding: 10px 16px;
        }

        #director-panel h3 {
            font-size: 18px;
            margin-bottom: 16px;
        }

        #director-panel .row {
            margin-bottom: 12px;
        }

        #director-panel .label {
            font-size: 13px;
        }

        #director-panel .value {
            font-size: 13px;
        }

        #director-panel.active {
            display: block;
        }

        #director-panel button:hover {
            background: #444;
        }

        #director-panel .waypoint-count {
            color: #ff0;
            margin-left: 8px;
        }

        #intro-text.draggable {
            pointer-events: auto;
            cursor: move;
            border: 1px dashed rgba(255, 255, 255, 0.5);
            resize: horizontal;
            overflow: auto;
        }

        #director-panel input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }

        #director-panel .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #director-panel .slider-value {
            color: #0f0;
            min-width: 40px;
        }

        h2 {
            font-size: 14px;
            color: #888;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }

        .value {
            font-size: 13px;
            color: #0f0;
        }

        button {
            background: #2a2a4e;
            color: #fff;
            border: none;
            padding: 8px 16px;
            margin: 4px 4px 4px 0;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }

        button:hover {
            background: #3a3a6e;
        }

        button.active {
            background: #0a6;
        }

        #metrics {
            background: #0a0a12;
            padding: 12px;
            font-size: 12px;
            line-height: 1.8;
            border: 1px solid #2a2a3e;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
        }

        .metric-row .label {
            color: #666;
        }

        .metric-row .value {
            color: #0f0;
        }

        #bundle-status {
            padding: 8px;
            text-align: center;
            font-size: 12px;
            margin-bottom: 12px;
        }

        #bundle-status.loading {
            background: #440;
            color: #ff0;
        }

        #bundle-status.loaded {
            background: #040;
            color: #0f0;
        }

        #bundle-status.error {
            background: #400;
            color: #f66;
        }

        #zoom-state {
            padding: 10px;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            border-radius: 4px;
        }

        #zoom-state.macro {
            background: #1a3a5a;
            color: #6af;
        }

        #zoom-state.transition {
            background: #3a3a1a;
            color: #ff0;
        }

        #zoom-state.local {
            background: #2a4a2a;
            color: #6f6;
        }

        #authority-indicator {
            font-size: 11px;
            text-align: center;
            margin-bottom: 12px;
            padding: 4px;
        }

        /* Tipping Text Anchor */
        #tipping-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 32px;
            font-weight: bold;
            color: #ff6666;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-out;
            z-index: 2000;
            text-align: center;
            letter-spacing: 2px;
        }

        /* Hourly injection table */
        #hourly-table {
            position: fixed;
            top: 180px;
            right: 24px;
            z-index: 999;
            pointer-events: none;
            font-family: 'IBM Plex Mono', monospace;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 16px;
            border: 1px solid #333;
            display: none;
            transform: scale(0.5);
            transform-origin: top right;
        }

        #hourly-table .ht-title {
            color: #888;
            font-size: 22px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 16px;
            text-align: center;
        }

        #hourly-table table {
            border-collapse: collapse;
            font-size: 24px;
        }

        #hourly-table th {
            color: #666;
            font-weight: 400;
            text-align: right;
            padding: 4px 16px;
            border-bottom: 2px solid #333;
        }

        #hourly-table th:first-child {
            text-align: left;
        }

        #hourly-table td {
            color: #aaa;
            text-align: right;
            padding: 4px 16px;
        }

        #hourly-table td:first-child {
            text-align: left;
            color: #666;
        }

        #hourly-table tr.peak td {
            color: #fff;
            font-weight: 700;
        }

        #hourly-table tr.current td {
            background: rgba(0, 255, 200, 0.15);
        }

        /* Splash screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'IBM Plex Mono', monospace;
        }

        #splash-screen .acronym {
            font-size: clamp(60px, 10vw, 108px);
            font-weight: 700;
            letter-spacing: 0.3em;
            color: #fff;
            margin-bottom: 24px;
            margin-top: -60px;
        }

        #splash-screen .subtitle {
            font-size: clamp(16px, 2.2vw, 24px);
            font-weight: 400;
            color: #888;
            letter-spacing: 0.1em;
        }

        #splash-screen .manifesto {
            position: absolute;
            bottom: 110px;
            max-width: 1200px;
            padding: 0 24px;
            text-align: left;
        }

        #splash-screen .manifesto p {
            font-size: clamp(10px, 1.3vw, 14px);
            font-weight: 700;
            color: #888;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #splash-screen .manifesto p:last-child {
            margin-bottom: 0;
        }

        #splash-screen.fade-out {
            opacity: 0;
            transition: opacity 2s ease-out;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="splash-screen">
        <div class="acronym">C/I/E/N</div>
        <div class="subtitle">Computación para la Integración Estratégica de Norteamerica</div>
        <div class="manifesto">
            <p>El desafío mayor de la arquitectura logística no reside en la cartografía de flujos —una descripción superficial del presente—, sino en la descomposición de los incentivos que los empujan y las restricciones que los contienen. Aislados, hacen posible decidir dónde intervenir y construir impacto sistémico.</p>
        </div>
    </div>
    <div id="container">
        <div id="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div id="tipping-text"></div>
            <div id="cell-hover-info" style="
                display: none;
                position: absolute;
                background: rgba(0,0,0,0.85);
                color: #0f0;
                font-family: monospace;
                font-size: 11px;
                padding: 6px 10px;
                border: 1px solid #0f0;
                pointer-events: none;
                white-space: pre;
                z-index: 1000;
            "></div>
        </div>
        <div id="controls">
            <h2>CIEN / FIELD Viewer</h2>

            <div id="bundle-status" class="loading">Loading bundle...</div>
            <div id="zoom-state" class="macro">MACRO_CIEN</div>
            <div id="authority-indicator">Authority: CIEN</div>
            <div id="timelapse-indicator" style="color: #4a9; font-weight: bold;">Mode: Daily Pain</div>

            <div class="control-group">
                <label>Hour of Day</label>
                <input type="range" id="hour-slider" min="0" max="23" value="8">
                <span class="value" id="hour-value">08:00</span>
            </div>

            <div class="control-group">
                <label>Time Scale (authoritative)</label>
                <span class="value" id="timescale-value" style="font-size: 12px;">--</span>
                <div style="font-size: 10px; color: #666;">1 day = 75s video</div>
            </div>

            <div class="control-group">
                <label>Zoom (scroll to change)</label>
                <input type="range" id="zoom-slider" min="1" max="200" value="2" disabled>
                <span class="value" id="zoom-value">0.02</span>
            </div>

            <div class="control-group">
                <button id="btn-pause">Resume</button>
                <button id="btn-reset">Reset</button>
                <button id="btn-macro">View Macro</button>
                <button id="btn-local">View Local</button>
            </div>

            <!-- Instant Replay Controls (visible when paused) -->
            <div class="control-group" id="replay-controls" style="display: none;">
                <label>Instant Replay (DVR)</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button id="btn-back-5s" style="padding: 6px 12px;">◄ -5s</button>
                    <span id="replay-time"
                        style="font-family: monospace; font-size: 14px; color: #0f0; min-width: 70px; text-align: center;">00:00:00</span>
                    <button id="btn-step-1s" style="padding: 6px 12px;">+1s ►</button>
                </div>
                <div id="replay-info" style="font-size: 10px; color: #666; margin-top: 4px;">Buffer: 0 snapshots</div>
            </div>

            <div class="control-group">
                <label>Scenario</label>
                <button id="btn-interserrana" disabled>Interserrana →</button>
                <button id="btn-twin-span">Twin Span →</button>
                <button id="btn-inovus">INOVUS →</button>
            </div>

            <div class="control-group">
                <label>Bundle Variant</label>
                <button id="btn-bundle-variant">Blocked Segments →</button>
            </div>

            <div class="control-group">
                <label>Debug (D to toggle, TAB to cycle)</label>
                <button id="btn-clear-debug-cache">Clear Debug Cache</button>
            </div>

            <div class="control-group">
                <label>Headless Test (Phase 1)</label>
                <button id="btn-headless-test">Run Invariant Check</button>
                <div id="headless-status" style="font-size: 11px; color: #666; margin-top: 6px;">Ready</div>
            </div>

            <div class="control-group" id="director-controls">
                <label>Director</label>
                <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                    <button id="btn-director-play">Play</button>
                    <button id="btn-director-stop">Stop</button>
                </div>
                <select id="director-script"
                    style="width: 100%; padding: 6px; background: #1a1a2e; color: #fff; border: 1px solid #2a2a4e; font-family: inherit; font-size: 12px;">
                    <option value="alienObserver" selected>Alien Observer</option>
                    <option value="alienObserverWithScenarios">Alien Observer + Scenarios</option>
                    <option value="narrativeIntro">Narrative Intro (Legacy)</option>
                    <option value="intro">Intro (Macro → Local)</option>
                    <option value="corridorTour">Corridor Tour</option>
                    <option value="zoomCycle">Zoom Cycle (Loop)</option>
                </select>
                <div id="director-status" style="font-size: 11px; color: #666; margin-top: 6px;">Ready</div>
            </div>

            <h2>Metrics</h2>
            <div id="metrics">
                <div class="metric-row">
                    <span class="label">Hour Inflow:</span>
                    <span class="value" id="m-inflow">0 t/hr</span>
                </div>
                <div class="metric-row">
                    <span class="label">Hour Capacity:</span>
                    <span class="value" id="m-cap">0 t/hr</span>
                </div>
                <div class="metric-row">
                    <span class="label">Throughput:</span>
                    <span class="value" id="m-throughput">--</span>
                </div>
                <div class="metric-row">
                    <span class="label">Backlog:</span>
                    <span class="value" id="m-backlog">--</span>
                </div>
                <div class="metric-row">
                    <span class="label">Field Mass:</span>
                    <span class="value" id="m-total">--</span>
                </div>
                <div class="metric-row">
                    <span class="label">Segments:</span>
                    <span class="value" id="m-segments">0</span>
                </div>
                <div class="metric-row">
                    <span class="label">Scenario α:</span>
                    <span class="value" id="m-alpha">0.00</span>
                </div>
            </div>

            <h2 style="margin-top: 20px;">Legend</h2>
            <div style="font-size: 11px; color: #888; line-height: 1.8;">
                <div><span style="color: hsl(220, 70%, 45%);">━</span> Low flow (thin)</div>
                <div><span style="color: hsl(170, 75%, 50%);">━━</span> Light flow</div>
                <div><span style="color: hsl(120, 80%, 50%);">━━━</span> Medium flow</div>
                <div><span style="color: hsl(60, 85%, 55%);">━━━━</span> High flow</div>
                <div><span style="color: hsl(30, 90%, 60%);">━━━━━</span> Peak flow (thick)</div>
                <div style="margin-top: 8px; color: #666;">
                    Thickness + color = cargo volume<br>
                    (CIEN routing equilibrium)
                </div>
            </div>

            <h2 style="margin-top: 20px;">Bundle Info</h2>
            <div id="bundle-info" style="font-size: 11px; color: #666; line-height: 1.6;"></div>

            <!-- Coordinate Picker (hidden by default) -->
            <div id="coord-picker"
                style="display: none; margin-top: 20px; padding: 10px; background: #1a1a2e; border: 1px solid #4af; border-radius: 4px;">
                <h2 style="color: #4af; margin: 0 0 10px 0;">Coordinate Picker</h2>
                <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                    Click on map to collect points.<br>
                    Press B again to close.
                </div>
                <div id="coord-list"
                    style="font-size: 10px; color: #6f6; max-height: 150px; overflow-y: auto; font-family: monospace; margin-bottom: 8px;">
                </div>
                <div style="display: flex; gap: 5px;">
                    <button id="copy-coords-btn" style="flex: 1; padding: 5px; font-size: 11px; cursor: pointer;">Copy
                        to Clipboard</button>
                    <button id="clear-coords-btn" style="padding: 5px; font-size: 11px; cursor: pointer;">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <button id="btn-avanzar">Avanzar</button>
    <button id="btn-skip">SKIP ▸▸</button>
    <div id="bottom-action-bar">
        <button id="btn-skip-to-local" class="primary">Skip to Local Sim</button>
        <div class="separator"></div>
        <button id="btn-bar-interserrana" disabled>Interserrana</button>
        <button id="btn-bar-inovus">INOVUS</button>
        <button id="btn-bar-twinspan">Twin Span</button>
        <div class="separator"></div>
        <button id="btn-bar-bundle-variant">Blocked Segments →</button>
        <button id="btn-bar-stress-test">Stress 5x</button>
    </div>
    <div id="intro-text"></div>

    <!-- Telemetry overlay (alien observer metrics) -->
    <div id="telemetry-overlay"></div>

    <!-- Scenario comparison overlay -->
    <div id="scenario-overlay">
        <div id="scenario-label"></div>
        <div id="scenario-intervention"></div>
    </div>
    <div id="montage-overlay">
        <div id="montage-day"></div>
        <div id="montage-clock"></div>
    </div>
    <!-- Macro layer month clock (shows during alienObserver) -->
    <div id="macro-month-clock"></div>
    <div id="hourly-table"></div>
    <div id="scenario-metrics"></div>
    <div id="comparison-table"></div>

    <!-- CONDITION B: Replay lockout banner -->
    <div id="replay-lockout-banner"></div>
    <!-- CONDITION B: Controls lockout overlay -->
    <div id="controls-lockout-overlay"></div>
    <!-- Kinematic replay indicator -->
    <div id="replay-mode-indicator"></div>

    <!-- Live logs panel (terminal style) -->
    <div id="live-logs">
        <div id="live-logs-content"></div>
    </div>

    <!-- Dimension stack (3 separate elements for independent control) -->
    <div id="dim-stack">
        <div class="dim-group">
            <div id="dim-1" class="dimension-box"></div>
            <div id="dim-1-desc" class="dimension-desc"></div>
        </div>
        <div id="dim-2" class="dimension-box"></div>
        <div id="dim-3" class="dimension-box"></div>
    </div>

    <div id="director-panel">
        <h3>Director Mode (E)</h3>
        <div class="row">
            <span class="label">Camera:</span>
            <span class="value" id="dp-camera">--</span>
        </div>
        <div class="row">
            <span class="label">Text pos:</span>
            <span class="value" id="dp-text-pos">--</span>
        </div>

        <hr style="border-color:#444; margin:12px 0;">
        <div class="row"><strong style="color:#ff0;">Timeline</strong> <span style="color:#666; margin-left:8px;"
                id="dp-step-count">0 steps</span></div>
        <div id="step-stack"></div>
        <div id="add-step-menu">
            <button id="add-flyto">+ FlyTo</button>
            <button id="add-text">+ Text</button>
            <button id="add-fadetext">+ Fade</button>
            <button id="add-action">+ Action</button>
            <button id="add-wait">+ Wait</button>
        </div>
        <div class="row">
            <button id="dp-play-all">▶ Play All</button>
            <button id="dp-export-timeline">Export</button>
            <button id="dp-clear-timeline">Clear</button>
        </div>

        <hr style="border-color:#444; margin:12px 0;">
        <div class="row"><strong style="color:#888;">Text Controls</strong></div>
        <div class="row">
            <button id="dp-toggle-drag">Enable Text Drag</button>
        </div>
        <div class="row">
            <span class="label">Font size:</span>
            <div class="slider-row">
                <input type="range" id="dp-font-size" min="12" max="60" value="30">
                <span class="slider-value" id="dp-font-size-value">30px</span>
            </div>
        </div>
        <div class="row">
            <span class="label">Max width:</span>
            <div class="slider-row">
                <input type="range" id="dp-max-width" min="200" max="1200" value="800">
                <span class="slider-value" id="dp-max-width-value">800px</span>
            </div>
        </div>
        <div class="row">
            <button id="dp-copy-text-css">Copy Text CSS</button>
        </div>
    </div>

    <script type="module">
        import { loadBundle, loadScenarioPairBundles, getHourlyInflow, getHourlyCapacity, getSegmentsInROI, getMetadata, createScenarioAdapter, createFieldGeometryProvider, getPharrWorldCoords, latLonToWorld } from '../overlay/bundleConsumer.js';
        import { POENodeLayer } from '../overlay/poeNodeLayer.js';
        import { ReynosaEastOverlay, getMetrics, getState, setLocalScenario, getCorridorEntries, getPhysicsDebugData, forceRebuildPhiBase, isPhiRebuilding, cycleParticleColorMode, getParticleColorMode, toggleDarkMode, toggleCongestionHeatmap, toggleCommuterDebug, isShowingCommuterDebug, setCommuterHeatmap, setHideParticles, setWebGLRenderer, getSourceShares, printSourceShares, setScenarioAlpha, setInterserranaScenario, setTwinSpanCapacityMultiplier, setTwinSpanSegments, step, reset, setSimTime, getSimTime, getMetricsPhase1, assertMassInvariantPhase1, captureSnapshot, restoreSnapshot, getSnapshotCount, getOldestSnapshotTime, getModelSpec, getLiveMassInSystemT, setReplayMode, updateReplayLotParticles, clearReplayLotParticles, setTrailsEnabled, clearParticleTrails, getParticleCount, setCorridorLabelOverride, updateInjectionRatios, setStressMode, isStressMode, cycleOverlayMode, getOverlayMode, toggleSpeedLimitEditMode, isSpeedLimitEditMode, hitTestSpeedNode, startDragSpeedNode, dragSpeedNode, endDragSpeedNode, isDraggingSpeedNode, copySpeedLimitPolylines, findNearestSegment, insertSpeedNode, deleteSpeedNode } from '../overlay/reynosaOverlay_v2.js';
        import { ParticleRenderer } from '../overlay/particleRenderer.js';
        import { loadWeightMaps, extractWeights, getInterpolatedWeight, hasWeightMaps, getSegmentPoeDistribution } from '../overlay/segmentWeights.js';
        import { MacroParticleLayer } from '../overlay/macroParticleLayer.js';
        import { Director, Scripts } from '../engine/director.js';
        import { buildPotentialField } from '../overlay/potentialField.js';
        import { QueueTimeSeries } from '../overlay/queueTimeSeries.js';

        // =====================================================================
        // REMOTE LOGGING (run: python log_server.py)
        // Disabled when crossOriginIsolated (SAB mode) - cross-origin fetch breaks COEP
        // =====================================================================
        const LOG_SERVER = 'http://localhost:9999';
        let logServerAvailable = false;

        // Clear remote log on page load (skip in SAB mode)
        if (!crossOriginIsolated) {
            fetch(`${LOG_SERVER}/clear`, { method: 'POST' }).then(() => {
                logServerAvailable = true;
                console.log('[LOG] Remote logging enabled - logs written to debug.log');
            }).catch(() => {
                console.log('[LOG] Remote log server not running. Start with: python log_server.py');
            });
        }

        // Remote logging - mission-critical + diagnostics
        const CRITICAL_PATTERNS = [
            '[Director]', 'Scenario:', 'alpha:', 'Queue phase', 'Local sim', 'STARTED', 'ENDED', 'Snapped', 'Transition', 'Clock montage', 'Metrics',
            // Diagnostics for corridor debugging
            'getModelSpec', 'initCorridorEntries', 'getSourceShares', 'CORRIDOR', 'MODULE LOADED', 'corridorEntryPoints', '_injectionPointRatios',
            'LocalSim', 'loadLocalSim', 'onAttach', 'fieldInitialized'
        ];
        let logQueue = [];
        let logFlushPending = false;

        const originalConsoleLog = console.log.bind(console);
        console.log = (...args) => {
            originalConsoleLog(...args);
            if (!logServerAvailable || crossOriginIsolated) return;  // Skip in SAB mode
            const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
            if (!CRITICAL_PATTERNS.some(p => msg.includes(p))) return;
            logQueue.push(msg);
            if (!logFlushPending) {
                logFlushPending = true;
                setTimeout(() => {
                    const batch = logQueue.splice(0, logQueue.length);
                    batch.forEach(m => {
                        fetch(`${LOG_SERVER}/log`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ msg: m })
                        }).catch(() => { });
                    });
                    logFlushPending = false;
                }, 500);
            }
        };

        // =====================================================================
        // LIVE LOG POLLING (reads from mission_critical.log via server)
        // Disabled in SAB mode to avoid COEP issues
        // =====================================================================
        let liveLogPolling = null;
        let lastLogLength = 0;
        let logFetchInFlight = false;

        function startLiveLogPolling() {
            if (liveLogPolling || crossOriginIsolated) return;  // Skip in SAB mode
            const content = document.getElementById('live-logs-content');

            async function pollOnce() {
                if (logFetchInFlight) return;
                logFetchInFlight = true;
                try {
                    const resp = await fetch('/mission_critical.log');
                    if (!resp.ok) return;
                    const text = await resp.text();
                    if (text.length === lastLogLength) return;
                    lastLogLength = text.length;

                    const lines = text.trim().split('\n').filter(l => l);
                    content.innerHTML = lines.map(line => {
                        const match = line.match(/^\[([^\]]+)\]\s*(.*)$/);
                        if (match) {
                            return `<div class="log-line"><span class="log-ts">${match[1]}</span> <span class="log-msg">${match[2]}</span></div>`;
                        }
                        return `<div class="log-line"><span class="log-msg">${line}</span></div>`;
                    }).join('');
                    content.scrollTop = content.scrollHeight;
                } catch (e) { }
                finally { logFetchInFlight = false; }
            }

            liveLogPolling = setInterval(pollOnce, 2000);
            pollOnce();
        }

        // =====================================================================
        // ZOOM STATE MACHINE (per spec)
        // =====================================================================

        const ZoomState = {
            MACRO_CIEN: 'MACRO_CIEN',
            TRANSITION_IN: 'TRANSITION_IN',
            LOCAL_FIELD: 'LOCAL_FIELD',
            TRANSITION_OUT: 'TRANSITION_OUT'
        };

        // Zoom thresholds (pixels per meter)
        // Must match REYNOSA_ACTIVATION in renderer_interfaces.js
        const Z_MACRO = 0.003;     // Below this: fully macro
        const Z_LOCAL = 0.032;     // Above this: fully local
        // Between Z_MACRO and Z_LOCAL: transition zone

        // Transition duration (ms)
        const TRANSITION_DURATION_MS = 800;

        // State
        let currentZoomState = ZoomState.MACRO_CIEN;
        let transitionStartTime = 0;
        let transitionProgress = 0;  // 0 to 1
        let forceMacroRender = false;  // Director override to show macro layer regardless of zoom

        // =====================================================================
        // COORDINATE PICKER
        // =====================================================================
        let coordPickerActive = false;
        let collectedCoords = [];

        // =====================================================================
        // DEBUG: PHYSICS X-RAY (press D to toggle, TAB to cycle layers)
        // Freezes sim when active. Layers: K, φ_base, Connectivity, Road Type
        // =====================================================================
        let showPhysicsDebug = false;
        let debugWasPaused = false;  // Track if sim was paused before debug
        let debugLayer = 0;  // 0=K, 1=φ_base(cost), 2=connectivity, 3=road type, 4=density, 5=φ_lots
        const DEBUG_LAYER_NAMES = ['K (conductance)', 'φ_pharr (sink routing)', 'Connectivity', 'Road Type', 'Density (ρ)', 'φ_lots (lot routing)'];
        const DEBUG_LAYER_COUNT = 6;

        // Cached debug stats (expensive N² computations)
        let _debugStatsCache = null;

        function togglePhysicsDebug() {
            showPhysicsDebug = !showPhysicsDebug;
            if (showPhysicsDebug) {
                // Freeze sim
                debugWasPaused = time.paused;
                time.paused = true;
                console.log(`[DEBUG] Layer ${debugLayer}: ${DEBUG_LAYER_NAMES[debugLayer]} (TAB to cycle)`);
            } else {
                // Restore pause state
                time.paused = debugWasPaused;
            }
        }

        function cycleDebugLayer() {
            if (!showPhysicsDebug) return;
            debugLayer = (debugLayer + 1) % DEBUG_LAYER_COUNT;
            console.log(`[DEBUG] Layer ${debugLayer}: ${DEBUG_LAYER_NAMES[debugLayer]}`);
        }

        function clearDebugCache() {
            _debugStatsCache = null;
            console.log('[DEBUG] Cache cleared - stats will recompute next frame');
        }

        /**
         * PHYSICS X-RAY OVERLAY
         * Press D to toggle, TAB to cycle layers:
         *   0: K (conductance) - grayscale, white=road
         *   1: φ_base (cost) - blue→yellow gradient
         *   2: Connectivity - green=valid, red=dead-end
         *   3: Road Type - orange=city, white=highway
         * Sources (cyan) and sinks (green) always shown.
         */
        function drawPhysicsDebug(ctx, camera) {
            if (!showPhysicsDebug) return;

            const debug = getPhysicsDebugData();
            if (!debug || !debug.N || !debug.phi_pharr) {
                ctx.fillStyle = '#ff0';
                ctx.font = '14px monospace';
                ctx.fillText('[D] Physics not initialized (phi computing...)', 20, 30);
                return;
            }

            const { N, roi, sinkCellIndices, roadCellIndices, conductiveCellIndices, lotCellIndices, G, phi, phi_pharr, phi_lots, Kxx, Kyy, S,
                nextHop_pharr, nextHop_lots, rho_restricted, rho_cleared,
                fieldToWorldX, fieldToWorldY, PHI_LARGE,
                roadTypeMap, ROAD_TYPE_CITY, loopCells, loopEnabled } = debug;
            // Use phi_pharr as primary visualization (cleared mass routing)
            const phi_base = phi_pharr;
            const nextHop = nextHop_pharr;

            const cellPx = Math.max(1, camera.metersToPixels(roi.cellSize));
            const N2 = N * N;

            // Use cached stats or compute once (expensive N² loops)
            if (!_debugStatsCache) {
                console.log('[DEBUG] Computing stats (N²=' + N2 + ')...');
                const t0 = performance.now();

                let phiMin = Infinity, phiMax = 0;
                let reachableCount = 0, roadPhiCount = 0;
                let kMin = Infinity, kMax = 0, kRoadCount = 0;
                for (let i = 0; i < N2; i++) {
                    const k = Math.max(Kxx[i], Kyy[i]);
                    if (phi_base[i] < PHI_LARGE) reachableCount++;
                    if (k > 0.01) {
                        kRoadCount++;
                        if (k < kMin) kMin = k;
                        if (k > kMax) kMax = k;
                        if (phi_base[i] < PHI_LARGE) {
                            roadPhiCount++;
                            if (phi_base[i] < phiMin) phiMin = phi_base[i];
                            if (phi_base[i] > phiMax) phiMax = phi_base[i];
                        }
                    }
                }
                const phiRange = (phiMax - phiMin) || 1;

                let q1 = 0, q2 = 0, q3 = 0, q4 = 0;
                for (let i = 0; i < N2; i++) {
                    const k = Math.max(Kxx[i], Kyy[i]);
                    if (k > 0.01 && phi_base[i] < PHI_LARGE) {
                        const t = (phi_base[i] - phiMin) / phiRange;
                        if (t < 0.25) q1++;
                        else if (t < 0.5) q2++;
                        else if (t < 0.75) q3++;
                        else q4++;
                    }
                }

                let hwSum = 0, hwCount = 0, citySum = 0, cityCount = 0;
                for (let i = 0; i < N2; i++) {
                    const k = Math.max(Kxx[i], Kyy[i]);
                    if (k > 0.01 && phi_base[i] < PHI_LARGE) {
                        if (roadTypeMap && roadTypeMap[i] === ROAD_TYPE_CITY) {
                            citySum += phi_base[i]; cityCount++;
                        } else {
                            hwSum += phi_base[i]; hwCount++;
                        }
                    }
                }
                const hwAvg = hwCount > 0 ? hwSum / hwCount : 0;
                const cityAvg = cityCount > 0 ? citySum / cityCount : 0;

                _debugStatsCache = {
                    phiMin, phiMax, phiRange, reachableCount, roadPhiCount,
                    kMin, kMax, kRoadCount,
                    q1, q2, q3, q4,
                    hwAvg, hwCount, cityAvg, cityCount
                };

                const elapsed = performance.now() - t0;
                console.log(`[DEBUG] Stats cached in ${elapsed.toFixed(1)}ms`);
                console.log(`[DEBUG LAYER] phi_base (roads only): min=${phiMin.toFixed(0)} max=${phiMax.toFixed(0)} range=${phiRange.toFixed(0)} roadPhiCells=${roadPhiCount}`);
                console.log(`[DEBUG LAYER] phi distribution: Q1(0-25%)=${q1} Q2(25-50%)=${q2} Q3(50-75%)=${q3} Q4(75-100%)=${q4}`);
                console.log(`[DEBUG LAYER] phi by road type: highway avg=${hwAvg.toFixed(0)} (n=${hwCount}) | city avg=${cityAvg.toFixed(0)} (n=${cityCount})`);
                console.log(`[DEBUG LAYER] K: min=${kMin.toFixed(3)} max=${kMax.toFixed(3)} roadCells=${kRoadCount}`);
            }

            const { phiMin, phiMax, phiRange, kMin, kMax, kRoadCount } = _debugStatsCache;

            ctx.save();

            // ─────────────────────────────────────────────────────────────────
            // LAYER 0: K (Conductance) - Grayscale on roads only
            // Uses roadCellIndices for O(roadCells) instead of O(N²)
            // Loop cells shown in CYAN (if enabled) or dim cyan (if disabled)
            // Lot cells shown in LIME GREEN (matches highlight lots feature)
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 0) {
                // Build loop cell set for O(1) lookup
                const loopCellSet = new Set(loopCells || []);

                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);
                    const k = Math.max(Kxx[idx], Kyy[idx]);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    // Check if this cell is part of the hardcoded loop
                    if (loopCellSet.has(idx)) {
                        // CYAN = loop cell (bright if enabled, dim if disabled)
                        ctx.fillStyle = loopEnabled ? '#00ffff' : '#006666';
                    } else {
                        // Normalize K to 0-1 range for gradient (kMin to kMax)
                        const kNorm = (k - kMin) / ((kMax - kMin) || 1);
                        const gray = Math.floor(128 + kNorm * 127);  // 128-255 range
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                    }
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }

                // Lot cells - lime green (matches highlight lots)
                if (lotCellIndices) {
                    ctx.fillStyle = 'rgba(0, 255, 150, 0.6)';
                    for (const idx of lotCellIndices) {
                        const fx = idx % N;
                        const fy = Math.floor(idx / N);
                        const wx = fieldToWorldX(fx + 0.5);
                        const wy = fieldToWorldY(fy + 0.5);
                        const screen = camera.worldToScreen(wx, wy);
                        ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                    }
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // LAYER 1: φ_base (Cost) - Blue→Yellow gradient on roads only
            // Uses LOG SCALE to handle skewed distribution
            // Blue = low cost (near sink), Yellow = high cost (far/penalized)
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 1) {
                // Use log scale for better gradient visibility
                const logMin = Math.log(phiMin + 1);
                const logMax = Math.log(phiMax + 1);
                const logRange = (logMax - logMin) || 1;

                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    if (phi_base[idx] >= PHI_LARGE) {
                        ctx.fillStyle = '#f00';  // Unreachable road (red = problem)
                    } else {
                        // Clip to Q1 range (where 95% of cells are) for better gradient
                        // Q1 = 0-25% of range, so effective max = phiMin + 0.25 * phiRange
                        const effectiveMax = phiMin + phiRange * 0.30;  // 30% for some headroom
                        let t = (phi_base[idx] - phiMin) / (effectiveMax - phiMin);
                        t = Math.min(1, Math.max(0, t));  // Clamp to [0,1]
                        // High-contrast: blue → cyan → yellow → red
                        let r, g, b;
                        if (t < 0.33) {
                            // Blue → cyan
                            const s = t * 3;
                            r = 0;
                            g = Math.floor(s * 255);
                            b = 255;
                        } else if (t < 0.66) {
                            // Cyan → yellow
                            const s = (t - 0.33) * 3;
                            r = Math.floor(s * 255);
                            g = 255;
                            b = Math.floor((1 - s) * 255);
                        } else {
                            // Yellow → red
                            const s = (t - 0.66) * 3;
                            r = 255;
                            g = Math.floor((1 - s) * 255);
                            b = 0;
                        }
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                    }
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // LAYER 2: Graph connectivity - roads only
            // Green = valid nextHop, Red = dead-end
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 2) {
                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    if (G[idx] > 0.001) {
                        ctx.fillStyle = '#0f0';  // Sink cell (bright green)
                    } else if (nextHop[idx] >= 0) {
                        ctx.fillStyle = '#2a2';  // Valid path (green)
                    } else {
                        ctx.fillStyle = '#f22';  // Dead-end (red)
                    }
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // LAYER 3: Road Type - Orange = city (2× cost), White = highway
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 3) {
                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    if (roadTypeMap && roadTypeMap[idx] === ROAD_TYPE_CITY) {
                        ctx.fillStyle = '#f80';  // City road (orange)
                    } else {
                        ctx.fillStyle = '#fff';  // Highway (white)
                    }
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // LAYER 4: Density (ρ) - Shows congestion buildup
            // Green = empty, Yellow = moderate, Red = congested
            // Only on road cells with K > 0
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 4) {
                // Find max density for normalization
                let rhoMax = 0;
                for (const idx of conductiveCellIndices) {
                    const rho = rho_restricted[idx] + rho_cleared[idx];
                    if (rho > rhoMax) rhoMax = rho;
                }
                // Use 50,000 kg as reference if no mass yet (RHO_CONGESTION_0)
                const rhoRef = Math.max(rhoMax, 50000);

                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    const rho = rho_restricted[idx] + rho_cleared[idx];
                    const t = Math.min(1, rho / rhoRef);

                    // Green → Yellow → Red gradient
                    let r, g, b;
                    if (t < 0.5) {
                        // Green → Yellow
                        const s = t * 2;
                        r = Math.floor(s * 255);
                        g = 255;
                        b = 0;
                    } else {
                        // Yellow → Red
                        const s = (t - 0.5) * 2;
                        r = 255;
                        g = Math.floor((1 - s) * 255);
                        b = 0;
                    }
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }

                // Log density stats
                if (!_debugStatsCache?.rhoLogged) {
                    console.log(`[DEBUG LAYER 4] Density: max=${rhoMax.toFixed(0)}kg, ref=${rhoRef.toFixed(0)}kg`);
                    if (_debugStatsCache) _debugStatsCache.rhoLogged = true;
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // LAYER 5: φ_lots (lot routing) - Restricted particle routing
            // Same blue→cyan→yellow→red gradient as layer 1
            // Blue = near lot (low cost), Red = far from lots or unreachable
            // ─────────────────────────────────────────────────────────────────
            if (debugLayer === 5) {
                // Find phi_lots min/max for scaling
                let phiLotsMin = Infinity, phiLotsMax = 0;
                for (let i = 0; i < N2; i++) {
                    if (phi_lots[i] < PHI_LARGE) {
                        if (phi_lots[i] < phiLotsMin) phiLotsMin = phi_lots[i];
                        if (phi_lots[i] > phiLotsMax) phiLotsMax = phi_lots[i];
                    }
                }
                const phiLotsRange = (phiLotsMax - phiLotsMin) || 1;

                for (const idx of conductiveCellIndices) {
                    const fx = idx % N;
                    const fy = Math.floor(idx / N);

                    const wx = fieldToWorldX(fx + 0.5);
                    const wy = fieldToWorldY(fy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    const phiVal = phi_lots[idx];
                    if (phiVal >= PHI_LARGE) {
                        // Unreachable - red
                        ctx.fillStyle = '#f00';
                    } else {
                        // Same gradient as layer 1: blue → cyan → yellow → red
                        const effectiveMax = phiLotsMin + phiLotsRange * 0.30;
                        let t = (phiVal - phiLotsMin) / (effectiveMax - phiLotsMin);
                        t = Math.min(1, Math.max(0, t));
                        let r, g, b;
                        if (t < 0.33) {
                            const s = t * 3;
                            r = 0;
                            g = Math.floor(s * 255);
                            b = 255;
                        } else if (t < 0.66) {
                            const s = (t - 0.33) * 3;
                            r = Math.floor(s * 255);
                            g = 255;
                            b = Math.floor((1 - s) * 255);
                        } else {
                            const s = (t - 0.66) * 3;
                            r = 255;
                            g = Math.floor((1 - s) * 255);
                            b = 0;
                        }
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                    }
                    ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                }

                // Highlight lot cells (sinks for this routing field) in cyan
                const { lotCellIndices } = debug;
                if (lotCellIndices) {
                    ctx.fillStyle = 'rgba(0,255,255,0.8)';
                    for (const idx of lotCellIndices) {
                        const fx = idx % N;
                        const fy = Math.floor(idx / N);
                        const wx = fieldToWorldX(fx + 0.5);
                        const wy = fieldToWorldY(fy + 0.5);
                        const screen = camera.worldToScreen(wx, wy);
                        ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
                    }
                }

                // Log phi_lots stats
                if (!_debugStatsCache?.phiLotsLogged) {
                    const reachable = Array.from({ length: N2 }, (_, i) => phi_lots[i] < PHI_LARGE).filter(x => x).length;
                    console.log(`[DEBUG LAYER 5] φ_lots: min=${phiLotsMin.toFixed(1)}, max=${phiLotsMax.toFixed(1)}, reachable=${reachable}/${N2}`);
                    if (_debugStatsCache) _debugStatsCache.phiLotsLogged = true;
                }
            }

            // ─────────────────────────────────────────────────────────────────
            // ALWAYS: Sources (S>0) - Cyan squares
            // ─────────────────────────────────────────────────────────────────
            ctx.fillStyle = 'rgba(0,255,255,1)';  // Cyan
            const { sourceCellIndices } = debug;
            for (const idx of sourceCellIndices) {
                const fx = idx % N;
                const fy = Math.floor(idx / N);

                const wx = fieldToWorldX(fx + 0.5);
                const wy = fieldToWorldY(fy + 0.5);
                const screen = camera.worldToScreen(wx, wy);

                const size = Math.max(cellPx, 6);
                ctx.fillRect(screen.x - size / 2, screen.y - size / 2, size, size);
            }

            // ─────────────────────────────────────────────────────────────────
            // ALWAYS: Sinks (G>0) - Green circles
            // ─────────────────────────────────────────────────────────────────
            ctx.fillStyle = 'rgba(0,255,0,0.9)';
            for (const idx of sinkCellIndices) {
                const fy = Math.floor(idx / N);
                const fx = idx % N;
                const wx = fieldToWorldX(fx + 0.5);
                const wy = fieldToWorldY(fy + 0.5);
                const screen = camera.worldToScreen(wx, wy);

                ctx.beginPath();
                ctx.arc(screen.x, screen.y, Math.max(cellPx / 2, 3), 0, Math.PI * 2);
                ctx.fill();
            }

            // ─────────────────────────────────────────────────────────────────
            // Lot numbers - Red labels at lot centroids (skip on Dijkstra layer)
            // ─────────────────────────────────────────────────────────────────
            const { regionMap, REGION_LOT, cellToLotIndex, lotToCellIndices, lotCount } = debug;
            if (lotToCellIndices && lotCount > 0 && debugLayer !== 1) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                for (let lotIdx = 0; lotIdx < lotCount; lotIdx++) {
                    const cells = lotToCellIndices[lotIdx];
                    if (!cells || cells.length === 0) continue;

                    // Compute centroid of lot cells
                    let sumX = 0, sumY = 0;
                    for (const idx of cells) {
                        const fx = idx % N;
                        const fy = Math.floor(idx / N);
                        sumX += fx;
                        sumY += fy;
                    }
                    const cx = sumX / cells.length;
                    const cy = sumY / cells.length;

                    const wx = fieldToWorldX(cx + 0.5);
                    const wy = fieldToWorldY(cy + 0.5);
                    const screen = camera.worldToScreen(wx, wy);

                    // Draw lot number with background for visibility
                    const text = `${lotIdx}`;
                    const metrics = ctx.measureText(text);
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(screen.x - metrics.width / 2 - 3, screen.y - 8, metrics.width + 6, 16);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillText(text, screen.x, screen.y);
                }
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }

            // ─────────────────────────────────────────────────────────────────
            // HUD: Show current layer name
            // ─────────────────────────────────────────────────────────────────
            ctx.fillStyle = '#fff';
            ctx.font = '14px monospace';
            ctx.fillText(`[D] Layer ${debugLayer}: ${DEBUG_LAYER_NAMES[debugLayer]} (TAB to cycle)`, 10, 20);

            // Show loop routing stats for Layer 0
            if (debugLayer === 0) {
                const loopCount = loopCells ? loopCells.length : 0;
                ctx.fillStyle = loopEnabled ? '#00ffff' : '#666666';
                ctx.fillText(`Loop routing: ${loopCount} cells, ${loopEnabled ? 'ENABLED' : 'DISABLED'} (cyan)`, 10, 38);
                if (loopCount === 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillText(`WARNING: No loop cells initialized!`, 10, 56);
                }
            }

            ctx.restore();
        }

        function toggleCoordPicker() {
            coordPickerActive = !coordPickerActive;
            document.getElementById('coord-picker').style.display = coordPickerActive ? 'block' : 'none';
            canvas.style.cursor = coordPickerActive ? 'crosshair' : 'grab';
            console.log('[CoordPicker]', coordPickerActive ? 'ACTIVE - click to collect points' : 'INACTIVE');
        }

        // =====================================================================
        // VIEW CAPTURE (V key) - for director script narrative beats
        // =====================================================================
        let capturedViews = [];

        function captureView() {
            // Compute world-space extent (what's visible on screen)
            const worldWidth = Math.round(camera.canvasWidth / camera.zoom);
            const worldHeight = Math.round(camera.canvasHeight / camera.zoom);

            const view = {
                x: Math.round(camera.centerWorld.x),
                y: Math.round(camera.centerWorld.y),
                zoom: parseFloat(camera.zoom.toFixed(6)),
                width: worldWidth,
                height: worldHeight,
                zoomState: currentZoomState,
                simHour: time.currentHour,
            };
            capturedViews.push(view);

            // World-space frame format (for WORLD_FRAMES)
            const frameDef = `{
    center: { x: ${view.x}, y: ${view.y} },
    width: ${view.width},
    height: ${view.height},
}`;

            // Legacy flyTo format (screen-dependent, avoid if possible)
            const flyToBeat = `{ type: 'flyTo', x: ${view.x}, y: ${view.y}, zoom: ${view.zoom}, duration: 2000 }`;

            console.log('═'.repeat(60));
            console.log('[VIEW CAPTURED] — World-Space Frame');
            console.log('═'.repeat(60));
            console.log(`  Center: (${view.x}, ${view.y})`);
            console.log(`  World extent: ${view.width} × ${view.height} meters`);
            console.log(`  Computed zoom: ${view.zoom} px/m`);
            console.log('');
            console.log('  ▸ WORLD_FRAMES entry (add to WORLD_FRAMES object):');
            console.log(frameDef);
            console.log('');
            console.log('  ▸ Director instruction (use flyToFrame with frame name):');
            console.log(`  { type: 'flyToFrame', frame: 'YOUR_FRAME_NAME', duration: 2000 }`);
            console.log('');
            console.log('  ▸ Legacy flyTo (screen-dependent, avoid):');
            console.log(`  ${flyToBeat}`);
            console.log('═'.repeat(60));

            // Copy world-space frame to clipboard
            navigator.clipboard.writeText(frameDef).then(() => {
                console.log('[VIEW] Frame definition copied to clipboard!');
            }).catch(() => {
                console.log('[VIEW] Clipboard write failed - copy from console');
            });

            return view;
        }

        function addCoordinate(worldX, worldY) {
            collectedCoords.push({ x: worldX, y: worldY });
            updateCoordList();
        }

        function updateCoordList() {
            const listEl = document.getElementById('coord-list');
            if (collectedCoords.length === 0) {
                listEl.innerHTML = '<span style="color: #666;">No points collected</span>';
                return;
            }
            listEl.innerHTML = collectedCoords.map((c, i) =>
                `${i + 1}. x: ${c.x.toFixed(1)}, y: ${c.y.toFixed(1)}`
            ).join('<br>');
        }

        function copyCoords() {
            if (collectedCoords.length === 0) {
                alert('No coordinates collected');
                return;
            }
            const text = JSON.stringify(collectedCoords, null, 2);
            navigator.clipboard.writeText(text).then(() => {
                console.log('[CoordPicker] Copied to clipboard:', text);
                alert('Coordinates copied to clipboard!');
            });
        }

        function clearCoords() {
            collectedCoords = [];
            updateCoordList();
        }

        function drawCoordMarkers(ctx, camera) {
            if (!coordPickerActive || collectedCoords.length === 0) return;

            ctx.save();
            for (let i = 0; i < collectedCoords.length; i++) {
                const c = collectedCoords[i];
                const screen = camera.worldToScreen(c.x, c.y);

                // Draw marker
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw label
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText(`${i + 1}`, screen.x, screen.y);
            }
            ctx.restore();
        }

        /**
         * Get authority f         t state.
         * Only MACRO_CIEN and LOCAL_FIELD compute truth.
         */
        function getAuthority(state) {
            if (state === ZoomState.MACRO_CIEN) return 'CIEN';
            if (state === ZoomState.LOCAL_FIELD) return 'FIELD';
            return null;  // Transitions have NO authority
        }

        /**
         * Update zoom          ed on camera zoom level.
         * Returns true if state changed.
         */
        function updateZoomState(zoom, now) {
            const prevState = currentZoomState;

            switch (currentZoomState) {
                case ZoomState.MACRO_CIEN:
                    // Only transition to local when zoom reaches Z_LOCAL threshold
                    // Stay in macro for the entire range below Z_LOCAL
                    if (zoom >= Z_LOCAL) {
                        currentZoomState = ZoomState.TRANSITION_IN;
                        transitionStartTime = now;
                        onTransitionInStart();
                    }
                    break;

                case ZoomState.TRANSITION_IN:
                    transitionProgress = Math.min(1, (now - transitionStartTime) / TRANSITION_DURATION_MS);
                    if (zoom < Z_MACRO) {
                        // User zoomed back out during transition
                        currentZoomState = ZoomState.TRANSITION_OUT;
                        transitionStartTime = now;
                        transitionProgress = 0;
                    } else if (zoom >= Z_LOCAL || transitionProgress >= 1) {
                        // Transition complete
                        currentZoomState = ZoomState.LOCAL_FIELD;
                        transitionProgress = 1;
                        onLocalFieldStart();
                    }
                    break;

                case ZoomState.LOCAL_FIELD:
                    if (zoom < Z_MACRO) {
                        // Start transition out
                        currentZoomState = ZoomState.TRANSITION_OUT;
                        transitionStartTime = now;
                        onTransitionOutStart();
                    } else if (zoom < Z_LOCAL && zoom >= Z_MACRO) {
                        // In the transition zone but still local
                        // Don't change state until fully zoomed out
                    }
                    break;

                case ZoomState.TRANSITION_OUT:
                    transitionProgress = Math.min(1, (now - transitionStartTime) / TRANSITION_DURATION_MS);
                    if (zoom >= Z_LOCAL) {
                        // User zoomed back in during transition
                        currentZoomState = ZoomState.TRANSITION_IN;
                        transitionStartTime = now;
                        transitionProgress = 0;
                    } else if (transitionProgress >= 1) {
                        // Transition complete
                        currentZoomState = ZoomState.MACRO_CIEN;
                        transitionProgress = 0;
                        onMacroCienStart();
                    }
                    break;
            }

            return prevState !== currentZoomState;
        }

        // =====================================================================
        // STATE TRANSITION HANDLERS
        // =====================================================================

        function onTransitionInStart() {
            console.log('[ZoomState] TRANSITION_IN started');
            // CIEN frozen, FIELD initialized but not running
            // No mass motion during transition
            if (macroParticles) macroParticles.paused = true;
        }

        function onLocalFieldStart() {
            console.log('[ZoomState] LOCAL_FIELD started - FIELD has authority');
            // FIELD clock starts, density evolves
            // FIELD always starts empty (ρ = 0)
            initFieldFromCien();
        }

        function onTransitionOutStart() {
            console.log('[ZoomState] TRANSITION_OUT started');
            // FIELD paused, visual fade
        }

        function onMacroCienStart() {
            console.log('[ZoomState] MACRO_CIEN started - CIEN has authority');
            // CIEN authoritative, FIELD not but attached (phi_base precomputed)
            // DO NOT detach - keep phi_base in memory for instant zoom-in
            if (macroParticles) macroParticles.paused = false;
        }

        /**
         * Initialize FIELD from CIEN bundle.
         * FIELD always starts empty - viewer watches consequences form.
         * NOTE: This delegates to loadLocalSim() to avoid race conditions
         */
        async function initFieldFromCien() {
            if (!bundleLoaded) return;

            // Skip if already loaded
            if (fieldInitialized) {
                console.log('[Handoff] FIELD already initialized');
                return;
            }

            console.log('[Handoff] Initializing FIELD from CIEN');
            console.log('[Handoff] FIELD starts with ρ = 0 (empty)');

            // Use shared loading mechanism to avoid race conditions
            await loadLocalSim();

            console.log('[Handoff] Inflow schedule:', getHourlyInflow(time.currentHour).total_kg.toFixed(0), 'kg/hr');
            console.log('[Handoff] Capacity:', getHourlyCapacity(time.currentHour).toFixed(0), 'kg/hr');
        }

        // =====================================================================
        // MACRO SCENARIO INTERPOLATION STATE
        // =====================================================================

        let macroAlpha = 0;                  // Current α ∈ [0, 1] (0=baseline, 1=interserrana)
        let macroTargetAlpha = 0;            // Target α for smooth ramp
        const MACRO_RAMP_DURATION = 1500;    // ms for smooth transition
        let macroRampStartTime = null;
        let macroRampStartAlpha = 0;
        let interserranaBundleLoaded = false; // True if dual-bundle mode

        // =====================================================================
        // TWIN SPAN SCENARIO STATE (independent of Interserrana)
        // =====================================================================

        let twinSpanAlpha = 0;
        let twinSpanTargetAlpha = 0;
        let twinSpanRampStartTime = null;
        let twinSpanRampStartAlpha = 0;
        const TWIN_SPAN_RAMP_DURATION = 800;

        // Twin span geometry (world meters, relative to PHARR origin)
        // Single polyline: approach start -> junction -> bridge end
        const TWIN_SPAN_POLYLINE = [
            { x: -363.6711606637666, y: -2694.9719926976927 },   // approach start (south)
            { x: -481.6711606637666, y: -2583.9719926976927 },   // junction
            { x: 236.39229354591248, y: 2212.2113236596624 }     // bridge end (north)
        ];
        // Split for addSegment compatibility
        const TWIN_SPAN_BRIDGE = [TWIN_SPAN_POLYLINE[1], TWIN_SPAN_POLYLINE[2]];
        const TWIN_SPAN_APPROACH = [TWIN_SPAN_POLYLINE[0], TWIN_SPAN_POLYLINE[1]];
        const TWIN_SPAN_BRIDGE_ID = 'twin_span_bridge';
        const TWIN_SPAN_APPROACH_ID = 'twin_span_approach';

        // =====================================================================
        // BUNDLE & DATA
        // =====================================================================

        const bundleStatus = document.getElementById('bundle-status');
        const bundleInfo = document.getElementById('bundle-info');
        let bundleLoaded = false;
        let fadeInStartTime = null;
        const FADE_IN_DURATION = 5000;  // 5 seconds fade-in
        let fadeInAlpha = 0;
        let scenarioAdapter = null;
        let geometryProvider = null;
        let rawBundle = null;
        // Store bundles for weight map switching (LAYER_A→baseline vs baseline→interserrana)
        let _storedBaselineBundle = null;
        let _storedLayerABundle = null;
        let _storedInterserranaBundle = null;
        // Cache POE distributions to avoid recomputing (expensive Map creation)
        let _storedBaselinePoeDistribution = null;
        let _storedInterserranaPoeDistribution = null;
        let segmentWeights = new Map();
        let fieldAttached = false;
        let fieldInitialized = false;
        let macroParticles = null;
        let queueTimeSeries = null;
        let queueData = null;  // Hourly queue results from bundle_baseline_queue_results.json
        let canvasBgDark = true;  // Dark mode default
        let glRendererRef = null;  // Shared WebGL renderer reference for macroParticles
        let poeNodeLayer = null;   // POE bleed visualization layer

        // =====================================================================
        // HOURLY INJECTION TABLE
        // Static table showing hourly inflow rates from bundle
        // =====================================================================

        function populateHourlyTable(bundle) {
            const container = document.getElementById('hourly-table');
            if (!container || !bundle?.inflow?.hourly_kg) return;

            const hourlyKg = bundle.inflow.hourly_kg;

            // Calculate daily total and find peak value
            let dailyTotal = 0;
            let peakValue = 0;
            for (let h = 0; h < 24; h++) {
                const kg = hourlyKg[h] || 0;
                dailyTotal += kg;
                if (kg > peakValue) peakValue = kg;
            }

            // Build table rows
            let rows = '';
            for (let h = 0; h < 24; h++) {
                const kg = hourlyKg[h] || 0;
                const tons = kg / 1000;
                const pct = dailyTotal > 0 ? (kg / dailyTotal * 100) : 0;
                const isPeak = kg === peakValue && kg > 0;
                const hourStr = h.toString().padStart(2, '0') + ':00';
                rows += `<tr class="${isPeak ? 'peak' : ''}">
                    <td>${hourStr}</td>
                    <td>${Math.round(tons).toLocaleString()}</td>
                    <td>${pct.toFixed(1)}%</td>
                </tr>`;
            }

            container.innerHTML = `
                <div class="ht-title">Inyección Horaria</div>
                <table>
                    <thead>
                        <tr><th>Hora</th><th>Tons</th><th>%</th></tr>
                    </thead>
                    <tbody>${rows}</tbody>
                </table>
            `;
            container.style.display = 'block';
        }

        function hideHourlyTable() {
            const container = document.getElementById('hourly-table');
            if (container) container.style.display = 'none';
        }

        // =====================================================================
        // BUNDLE VARIANT SYSTEM
        // Switches between bundle sets (e.g., '' vs '_blockedsegments')
        // One action switches BOTH baseline and interserrana bundles together
        // =====================================================================

        let currentBundleSuffix = '';  // '' = default, '_blockedsegments' = variant, '_LAYER_A' = layer A
        const BUNDLE_VARIANTS = ['', '_blockedsegments', '_LAYER_A'];  // Available variants

        /**
         * Switch to a different bundle variant.
         * Reloads BOTH baseline and interserrana bundles with the new suffix.
         * Rebuilds BOTH macro and field layers.
         * FAILS HARD if any bundle is missing.
         *
         * @param {string} suffix - Bundle suffix (e.g., '' or '_blockedsegments')
         */
        async function switchBundleVariant(suffix) {
            if (suffix === currentBundleSuffix) {
                console.log(`[BUNDLE] Already on variant: "${suffix || 'default'}"`);
                return;
            }

            console.log(`[BUNDLE] Switching variant: "${currentBundleSuffix || 'default'}" → "${suffix || 'default'}"`);
            bundleStatus.className = 'loading';
            bundleStatus.textContent = `Switching to ${suffix || 'default'}...`;

            const cacheBust = '?t=' + Date.now();
            const baselinePath = `./bundle_baseline${suffix}.json${cacheBust}`;
            const interserranaPath = `./interserrana_bundle${suffix}.json${cacheBust}`;

            try {
                // Fetch BOTH bundles - FAIL HARD if either is missing
                const [baselineResponse, interserranaResponse] = await Promise.all([
                    fetch(baselinePath),
                    fetch(interserranaPath),
                ]);

                if (!baselineResponse.ok) {
                    throw new Error(`Baseline bundle missing: ${baselinePath} (HTTP ${baselineResponse.status})`);
                }
                if (!interserranaResponse.ok) {
                    throw new Error(`Interserrana bundle missing: ${interserranaPath} (HTTP ${interserranaResponse.status})`);
                }

                const baselineBundle = await baselineResponse.json();
                const interserranaBundle = await interserranaResponse.json();

                console.log(`[BUNDLE] Loaded: baseline${suffix} + interserrana${suffix}`);

                // Update state
                currentBundleSuffix = suffix;
                rawBundle = baselineBundle;
                hideHourlyTable();

                // Reload into bundleConsumer
                loadScenarioPairBundles(baselineBundle, interserranaBundle);
                loadWeightMaps(baselineBundle, interserranaBundle, { hs2Filter: null, poeFilter: null });

                // Update interserrana scenario adapter
                const interserranaScenarioAdapter = {
                    getPharrInflow(hour) {
                        const h = Math.floor(hour) % 24;
                        const total = interserranaBundle.inflow?.hourly_kg?.[h] || 0;
                        const byHs2 = interserranaBundle.inflow?.hourly_kg_by_hs2?.[h];
                        return { hs2_kg: byHs2 || { "99": total } };
                    },
                    getPharrGateCapacity(hour) {
                        const h = Math.floor(hour) % 24;
                        const cap = interserranaBundle.capacity?.hourly_kg?.[h] || 0;
                        return { cap_kg_per_hour: cap };
                    },
                };
                setInterserranaScenario(interserranaScenarioAdapter);

                // Rebuild scenario adapter and geometry provider
                scenarioAdapter = createScenarioAdapter();
                geometryProvider = createFieldGeometryProvider();

                // Rebuild MACRO layer
                const segments = getSegmentsInROI();
                macroParticles.clear();
                for (const seg of segments) {
                    const weight = getSegmentWeight(seg.segment_id);
                    macroParticles.addSegment(
                        seg.segment_id,
                        seg.points.map(p => ({ x: p.x, y: p.y })),
                        weight
                    );
                }
                macroParticles.buildConnectivity();
                macroParticles.detectSourcesFromOrigins();  // Re-match origins to new segments

                // Update POE Bleed Visualization Layer with new tipping data
                if (poeNodeLayer && baselineBundle.tipping_summary) {
                    poeNodeLayer.setTippingSummary(baselineBundle.tipping_summary);
                    
                    const lambdas = {};
                    for (const [k, v] of Object.entries(baselineBundle.tipping_summary)) {
                        if (v.first_flip_lambda_total !== undefined) {
                            lambdas[k] = v.first_flip_lambda_total;
                        }
                    }
                    poeNodeLayer.setLambdaTotals(lambdas);
                    console.log(`[BUNDLE] Updated POE Tipping Summary (${Object.keys(baselineBundle.tipping_summary).length} POEs)`);
                }

                // Update POE distributions
                const baselinePoeDistribution = getSegmentPoeDistribution(baselineBundle);
                const interserranaPoeDistribution = getSegmentPoeDistribution(interserranaBundle);
                macroParticles.setScenarioPoeDistributions(baselinePoeDistribution, interserranaPoeDistribution);

                // Rebuild FIELD layer if attached
                if (fieldAttached) {
                    console.log('[BUNDLE] Rebuilding field layer...');
                    ReynosaEastOverlay.onDetach();
                    fieldAttached = false;
                    fieldInitialized = false;

                    await ReynosaEastOverlay.onAttach(createRendererContext());
                    ReynosaEastOverlay.setCitySegments(_citySegmentsTransformed);
                    setLocalScenario({ renderMode: 'particles' });
                    fieldAttached = true;
                    fieldInitialized = true;
                }

                // Update cached segment data
                _cienSegmentsWithBbox = segments.map(seg => {
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const pt of seg.points) {
                        if (pt.x < minX) minX = pt.x;
                        if (pt.x > maxX) maxX = pt.x;
                        if (pt.y < minY) minY = pt.y;
                        if (pt.y > maxY) maxY = pt.y;
                    }
                    return { seg, minX, maxX, minY, maxY };
                });

                // Update UI
                bundleStatus.className = 'loaded';
                const VARIANT_NAMES = { '': 'default', '_blockedsegments': 'blocked', '_LAYER_A': 'LAYER_A' };
                bundleStatus.textContent = `Bundles: ${VARIANT_NAMES[suffix] || suffix}`;
                // Sync both sidebar and bottom bar buttons (uses syncBundleVariantButtons from outer scope)

                const meta = getMetadata();
                bundleInfo.innerHTML = `
                    Layer: ${meta.layer}<br>
                    Variant: ${suffix || 'default'}<br>
                    Segments: ${segments.length}<br>
                    Generated: ${new Date(meta.generated_at).toLocaleString()}
                `;

                console.log(`[BUNDLE] Switch complete: ${segments.length} segments`);

            } catch (err) {
                console.error('[BUNDLE] Switch FAILED:', err.message);
                bundleStatus.className = 'error';
                bundleStatus.textContent = `FAILED: ${err.message}`;
                throw err;  // Re-throw to make failure visible
            }
        }

        function toggleBundleVariant() {
            const nextIdx = (BUNDLE_VARIANTS.indexOf(currentBundleSuffix) + 1) % BUNDLE_VARIANTS.length;
            const nextSuffix = BUNDLE_VARIANTS[nextIdx];
            switchBundleVariant(nextSuffix);
        }

        /**
         * Load bundles for Alien Observer mode.
         * Uses LAYER_A as baseline (α=0) and full baseline as target (α=1).
         * This enables the α-transition from simplified → detailed view.
         */
        // REMOVED: loadAlienPathBundles() was loading baseline twice
        // All bundle loading now consolidated into loadBundleFromFile()

        function computeSegmentWeights(bundle) {
            // Single-bundle mode: use canonical extractor (linear max-normalized).
            // No POE hardcode: aggregate across all POEs.
            segmentWeights = extractWeights(bundle, null, null);
            console.log('[CIEN] Segment weights computed (canonical):', segmentWeights.size, 'segments');
        }

        /**
         * Update twin span visual segments and capacity.
         * @param {number} alpha - 0 = off, 1 = fully active
         */
        function updateTwinSpanState(alpha) {
            // MACRO view: update particle layer segments
            if (macroParticles) {
                if (alpha > 0.01) {
                    // Add/update twin span segments with 50% of traffic
                    const weight = 0.5 * alpha;
                    if (!macroParticles.segments.has(TWIN_SPAN_BRIDGE_ID)) {
                        macroParticles.addSegment(TWIN_SPAN_BRIDGE_ID, TWIN_SPAN_BRIDGE, weight);
                        macroParticles.addSegment(TWIN_SPAN_APPROACH_ID, TWIN_SPAN_APPROACH, weight);
                        console.log('[Twin Span] Segments added');
                    } else {
                        macroParticles.segments.get(TWIN_SPAN_BRIDGE_ID).weight = weight;
                        macroParticles.segments.get(TWIN_SPAN_APPROACH_ID).weight = weight;
                    }
                    // Scale original PHARR approach segments to 50%
                    scalePharrSegments(1 - 0.5 * alpha);
                } else {
                    // Remove twin span segments when fully off
                    macroParticles.removeSegment(TWIN_SPAN_BRIDGE_ID);
                    macroParticles.removeSegment(TWIN_SPAN_APPROACH_ID);
                    // Restore original PHARR approach weights
                    scalePharrSegments(1.0);
                }
            }

            // LOCAL view: update road rendering in reynosaOverlay
            setTwinSpanSegments([TWIN_SPAN_BRIDGE, TWIN_SPAN_APPROACH], alpha);

            // Capacity: 1x at alpha=0, 2x at alpha=1
            setTwinSpanCapacityMultiplier(1 + alpha);
        }

        /**
         * Scale PHARR approach segment weights for 50/50 traffic split.
         */
        function scalePharrSegments(factor) {
            if (!macroParticles) return;
            const pharr = getPharrWorldCoords();
            for (const [id, seg] of macroParticles.segments) {
                if (id.startsWith('twin_span')) continue;
                const last = seg.polyline[seg.polyline.length - 1];
                const dist = Math.hypot(last.x - pharr.x, last.y - pharr.y);
                if (dist < 3000) {
                    // Store original weight if not already stored
                    if (seg._origWeight === undefined) {
                        seg._origWeight = seg.weight;
                    }
                    seg.weight = seg._origWeight * factor;
                }
            }
        }

        // Reynosa city segments (merged with CIEN for FIELD view)
        let reynosaCitySegments = [];

        // Cached segment data for LOCAL_FIELD rendering (precomputed bboxes)
        let _cienSegmentsWithBbox = null;
        let _citySegmentsTransformed = null;

        async function loadBundleFromFile() {
            try {
                bundleStatus.className = 'loading';
                bundleStatus.textContent = 'Loading bundles...';

                // Load ALL bundles in PARALLEL - including LAYER_A for alien observer mode
                // This avoids the previous bug where baseline was fetched twice
                const cacheBust = '?t=' + Date.now();
                const suffix = currentBundleSuffix;
                const [baselineResponse, layerAResponse, interserranaResponse, cityResponse, originsResponse] = await Promise.all([
                    fetch(`./bundle_baseline${suffix}.json${cacheBust}`),
                    fetch(`./bundle_baseline_LAYER_A.json${cacheBust}`),
                    fetch(`./interserrana_bundle${suffix}.json${cacheBust}`),
                    fetch('./reynosa_city_bundle.json' + cacheBust),
                    fetch('../data/mexican_origins.json' + cacheBust),
                ]);

                if (!baselineResponse.ok) throw new Error(`Baseline: HTTP ${baselineResponse.status}`);
                if (!layerAResponse.ok) throw new Error(`LAYER_A: HTTP ${layerAResponse.status}`);
                if (!interserranaResponse.ok) throw new Error(`Interserrana: HTTP ${interserranaResponse.status}`);
                if (!cityResponse.ok) throw new Error(`City: HTTP ${cityResponse.status}`);
                if (!originsResponse.ok) throw new Error(`Origins: HTTP ${originsResponse.status}`);

                const baselineBundle = await baselineResponse.json();

                // LAYER_A bundle for alien observer mode (α=0 → α=1 transition)
                const layerABundle = await layerAResponse.json();
                console.log('[Init] LAYER_A bundle loaded');

                const interserranaBundle = await interserranaResponse.json();
                console.log('[Init] Interserrana bundle loaded');

                const cityBundle = await cityResponse.json();
                reynosaCitySegments = cityBundle.geometry?.segments_in_roi || [];

                const mexicanOrigins = await originsResponse.json();

                // Store bundles for later weight map switching
                _storedBaselineBundle = baselineBundle;
                _storedLayerABundle = layerABundle;
                _storedInterserranaBundle = interserranaBundle;

                // Init POE Bleed Visualization Layer
                poeNodeLayer = new POENodeLayer();

                if (baselineBundle.tipping_summary) {
                    poeNodeLayer.setTippingSummary(baselineBundle.tipping_summary);

                    const lambdas = {};
                    for (const [k, v] of Object.entries(baselineBundle.tipping_summary)) {
                        if (v.first_flip_lambda_total !== undefined) {
                            lambdas[k] = v.first_flip_lambda_total;
                        }
                    }
                    poeNodeLayer.setLambdaTotals(lambdas);
                    poeNodeLayer.onShowTippingText = (poe, name) => showTippingText(poe, name);
                }

                // Setup scenario pairs - replicates original two-step loading:
                // Step 1: Set up baseline → interserrana (if available) - enables scenario comparison
                // Step 2: Set up LAYER_A → baseline (if available) - enables α visual transition

                rawBundle = baselineBundle;

                // Step 1: Interserrana scenario setup (for scenario comparison button/director)
                if (interserranaBundle) {
                    loadScenarioPairBundles(baselineBundle, interserranaBundle);
                    loadWeightMaps(baselineBundle, interserranaBundle, { hs2Filter: null, poeFilter: null });

                    const interserranaScenarioAdapter = {
                        getPharrInflow(hour) {
                            const h = Math.floor(hour) % 24;
                            const total = interserranaBundle.inflow?.hourly_kg?.[h] || 0;
                            const byHs2 = interserranaBundle.inflow?.hourly_kg_by_hs2?.[h];
                            return { hs2_kg: byHs2 || { "99": total } };
                        },
                        getPharrGateCapacity(hour) {
                            const h = Math.floor(hour) % 24;
                            const cap = interserranaBundle.capacity?.hourly_kg?.[h] || 0;
                            return { cap_kg_per_hour: cap };
                        },
                    };
                    setInterserranaScenario(interserranaScenarioAdapter);
                    interserranaBundleLoaded = true;
                    document.getElementById('btn-interserrana').disabled = false;
                    document.getElementById('btn-bar-interserrana').disabled = false;
                } else {
                    loadBundle(baselineBundle);
                    computeSegmentWeights(baselineBundle);
                }

                // Step 2: LAYER_A setup (for α visual transition) - replaces weight maps
                if (layerABundle) {
                    currentBundleSuffix = '_LAYER_A';
                    rawBundle = layerABundle;

                    loadScenarioPairBundles(layerABundle, baselineBundle);
                    loadWeightMaps(layerABundle, baselineBundle, { hs2Filter: null, poeFilter: null });

                    const targetScenarioAdapter = {
                        getPharrInflow(hour) {
                            const h = Math.floor(hour) % 24;
                            const total = baselineBundle.inflow?.hourly_kg?.[h] || 0;
                            const byHs2 = baselineBundle.inflow?.hourly_kg_by_hs2?.[h];
                            return { hs2_kg: byHs2 || { "99": total } };
                        },
                        getPharrGateCapacity(hour) {
                            const h = Math.floor(hour) % 24;
                            const cap = baselineBundle.capacity?.hourly_kg?.[h] || 0;
                            return { cap_kg_per_hour: cap };
                        },
                    };
                    setInterserranaScenario(targetScenarioAdapter);
                    interserranaBundleLoaded = true;
                }

                // Status reflects what's loaded
                bundleStatus.className = 'loaded';
                if (layerABundle && interserranaBundle) {
                    bundleStatus.textContent = 'Bundles: LAYER_A + baseline + interserrana';
                } else if (layerABundle) {
                    bundleStatus.textContent = 'Bundles: LAYER_A + baseline';
                } else if (interserranaBundle) {
                    bundleStatus.textContent = 'Bundles: baseline + interserrana';
                } else {
                    bundleStatus.textContent = 'Bundle: ' + baselineBundle.metadata.scenario_hash;
                }

                fadeInStartTime = performance.now();

                const meta = getMetadata();
                const segments = getSegmentsInROI();
                const poeCount = Object.keys(baselineBundle.segment_load_kg_by_poe_hs2 || {}).length;

                // Debug: compare geometry segments vs flow data segments
                const geometrySegIds = new Set(segments.map(s => s.segment_id));
                const flowSegIds = new Set();
                const flowData = baselineBundle.segment_load_kg_by_poe_hs2 || {};
                for (const poe in flowData) {
                    for (const hs2 in flowData[poe]) {
                        for (const segId in flowData[poe][hs2]) {
                            flowSegIds.add(segId);
                        }
                    }
                }
                const inFlowNotGeom = [...flowSegIds].filter(id => !geometrySegIds.has(id));
                const inGeomNotFlow = [...geometrySegIds].filter(id => !flowSegIds.has(id));
                console.log(`[SEGMENT CHECK] geometry=${geometrySegIds.size} flow=${flowSegIds.size} inFlowNotGeom=${inFlowNotGeom.length} inGeomNotFlow=${inGeomNotFlow.length}`);
                if (inFlowNotGeom.length > 0) {
                    console.log(`[MISSING FROM GEOMETRY] first 10:`, inFlowNotGeom.slice(0, 10));
                }

                bundleInfo.innerHTML = `
                    Layer: ${meta.layer}<br>
                    Segments: ${segments.length}<br>
                    POEs: ${poeCount}<br>
                    Mode: ${interserranaBundleLoaded ? 'Dual-scenario' : 'Single-scenario'}<br>
                    Generated: ${new Date(meta.generated_at).toLocaleString()}
                `;

                scenarioAdapter = createScenarioAdapter();
                geometryProvider = createFieldGeometryProvider();

                // Mass-proportional particles: 50 tons per particle
                // 56M tons / 50t = 1.12M particles over 300s = 3,733/sec spawn rate
                const TOTAL_ANNUAL_KG = 56_000_000_000;
                const KG_PER_PARTICLE = window.MACRO_KG_PER_PARTICLE = 50_000;  // 50 tons per particle
                const PLAYBACK_SECONDS = 300;
                const TOTAL_PARTICLES = TOTAL_ANNUAL_KG / KG_PER_PARTICLE;  // 1,866,667
                const MACRO_SPAWN_RATE = TOTAL_PARTICLES / PLAYBACK_SECONDS;  // 6,222/sec

                macroParticles = new MacroParticleLayer({
                    maxParticles: 20000,
                    spawnPerSecondBudget: MACRO_SPAWN_RATE,
                    spawnEpsilon: 1e-6,
                    spawnWeightPower: 0.85,  // closer to 1.0 = stronger hierarchy (heavy corridors dominate)
                    particleSpeed: 80_000,  // ~3-4s transit for 300km path
                    spawnRampUpSec: 10,  // ramp from 0 to full spawn rate over 10 seconds
                });

                for (const seg of segments) {
                    const weight = getSegmentWeight(seg.segment_id);
                    macroParticles.addSegment(
                        seg.segment_id,
                        seg.points.map(p => ({ x: p.x, y: p.y })),
                        weight
                    );
                }

                macroParticles.buildConnectivity();

                if (mexicanOrigins) {
                    macroParticles.setOrigins(mexicanOrigins, latLonToWorld);
                    macroParticles.detectSourcesFromOrigins();
                }

                // POE distributions match the scenario pair setup above
                // Cache distributions for later reuse (avoid expensive Map recreation)
                _storedBaselinePoeDistribution = getSegmentPoeDistribution(baselineBundle);
                _storedInterserranaPoeDistribution = interserranaBundle
                    ? getSegmentPoeDistribution(interserranaBundle)
                    : null;

                if (layerABundle) {
                    const layerAPoeDistribution = getSegmentPoeDistribution(layerABundle);
                    macroParticles.setScenarioPoeDistributions(layerAPoeDistribution, _storedBaselinePoeDistribution);
                    console.log('[Init] ✓ Routing: α=0 → LAYER_A, α=1 → BASELINE');

                    // Start at α=0 (LAYER_A)
                    setScenarioAlpha(0);
                    macroAlpha = 0;
                    macroTargetAlpha = 0;
                } else if (interserranaBundle) {
                    macroParticles.setScenarioPoeDistributions(_storedBaselinePoeDistribution, _storedInterserranaPoeDistribution);
                    console.log('[Init] ✓ Routing: α=0 → BASELINE, α=1 → INTERSERRANA (NO LAYER_A!)');
                } else {
                    macroParticles.setScenarioPoeDistributions(_storedBaselinePoeDistribution, null);
                    console.log('[Init] ✓ Routing: BASELINE only (no α transition)');
                }

                if (glRendererRef && glRendererRef.isAvailable()) {
                    macroParticles.setWebGLRenderer(glRendererRef);
                }

                // Apply pending potential field (gravity sink effect)
                if (pendingPotentialField) {
                    macroParticles.setPotentialField(pendingPotentialField);
                }

                // Apply US-side routing data (destination loads + POE distribution)
                if (baselineBundle.segment_load_kg_by_destination_hs2) {
                    macroParticles.setDestinationData(
                        baselineBundle.segment_load_kg_by_destination_hs2,
                        baselineBundle.poe_to_destination_distribution
                    );
                    console.log('[Init] US-side routing data applied');
                }

                _cienSegmentsWithBbox = segments.map(seg => {
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const pt of seg.points) {
                        if (pt.x < minX) minX = pt.x;
                        if (pt.x > maxX) maxX = pt.x;
                        if (pt.y < minY) minY = pt.y;
                        if (pt.y > maxY) maxY = pt.y;
                    }
                    return { seg, minX, maxX, minY, maxY };
                });

                _citySegmentsTransformed = reynosaCitySegments.map(seg => {
                    if (!seg.geometry_coordinates || seg.geometry_coordinates.length < 2) return null;
                    const points = seg.geometry_coordinates.map(([lat, lon]) => latLonToWorld(lat, lon));
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const pt of points) {
                        if (pt.x < minX) minX = pt.x;
                        if (pt.x > maxX) maxX = pt.x;
                        if (pt.y < minY) minY = pt.y;
                        if (pt.y > maxY) maxY = pt.y;
                    }
                    return { points, minX, maxX, minY, maxY };
                }).filter(Boolean);

                // Ensure particles are running - Director may have already called macroPause
                // before macroParticles existed (slow network load on deployed site)
                macroParticles.paused = false;

                // Set bundleLoaded LAST after all processing complete
                // This ensures splash doesn't dismiss until everything is ready
                bundleLoaded = true;
                console.log(`[Init] Ready (local sim deferred)`);

            } catch (err) {
                bundleStatus.className = 'error';
                bundleStatus.textContent = 'Error: ' + err.message;
                console.error('[Bundle] Failed:', err);
            }
        }

        function createRendererContext() {
            if (!geometryProvider) {
                return { geometry: null, scenario: scenarioAdapter };
            }

            // Get CIEN segments + reuse already-transformed city segments
            const cienSegments = geometryProvider.getRoadSegments();
            const citySegsForField = _citySegmentsTransformed.map(s => ({ id: 'city', points: s.points }));
            const allSegments = [...cienSegments, ...citySegsForField];

            return {
                geometry: {
                    worldBounds: geometryProvider.getWorldBounds(),
                    poePoints: { PHARR: getPharrWorldCoords() },
                    roadSegments: allSegments,
                },
                scenario: scenarioAdapter,
            };
        }

        // Deferred local sim initialization (heavy - call when screen shows static text)
        // Track in-progress load to prevent race conditions
        let _loadLocalSimPromise = null;

        async function loadLocalSim() {
            console.log('[LocalSim] loadLocalSim() ENTERED, fieldInitialized=' + fieldInitialized + ', _loadLocalSimPromise=' + !!_loadLocalSimPromise);
            if (fieldInitialized) {
                console.log('[LocalSim] Already loaded');
                return;
            }
            // If load already in progress, wait for it instead of starting another
            if (_loadLocalSimPromise) {
                console.log('[LocalSim] Waiting for in-progress load...');
                return _loadLocalSimPromise;
            }
            console.log('[LocalSim] Loading...');
            const t0 = performance.now();
            _loadLocalSimPromise = (async () => {
                await ReynosaEastOverlay.onAttach(createRendererContext());
                ReynosaEastOverlay.setCitySegments(_citySegmentsTransformed);
                setLocalScenario({ renderMode: 'particles' });
                fieldAttached = true;
                fieldInitialized = true;
                console.log(`[LocalSim] Ready in ${(performance.now() - t0).toFixed(0)}ms`);
            })();
            await _loadLocalSimPromise;
        }

        // =====================================================================
        // CAMERA
        // =====================================================================

        // ─────────────────────────────────────────────────────────────────
        // WORLD-SPACE FRAME DEFINITIONS (semantic truth)
        // Frames are defined in world coordinates, not screen coordinates.
        // Zoom is COMPUTED at runtime to fit the frame to the viewport.
        // This ensures all viewers see the same spatial relationships.
        // ─────────────────────────────────────────────────────────────────
        const WORLD_FRAMES = {
            // Opening frame: full continent view (Mexico + US)
            opening: {
                center: { x: -610983, y: 354591 },
                width: 6221218,
                height: 3084579,
            },
            // Macro view: all corridors visible (NLD → Pharr → Dallas/Houston)
            macro: {
                center: { x: 9880, y: 382686 },
                width: 2400000,
                height: 1900000,
            },
            // Wide regional: NLD, Pharr, major metros
            wide: {
                center: { x: -68197, y: 119285 },
                width: 600000,
                height: 480000,
            },
            // Reynosa local: the simulation area
            reynosa: {
                center: { x: -8491, y: -5982 },
                width: 22500,
                height: 18000,
            },
            // Local sim intro: wider view for telemetry phase
            localSimIntro: {
                center: { x: -8469, y: -6840 },
                width: 57529,
                height: 24913,
            },
            // Scenario comparison: tighter view for 7-day sim runs
            scenarioRun: {
                center: { x: 4818, y: -9210 },
                width: 35014,
                height: 15163,
            },
            // Twinspan bridge detail (CBP facility zoom)
            twinspan: {
                center: { x: -347, y: -2573 },
                width: 12970,
                height: 7028,
            },
            // Inovus lot detail
            inovus: {
                center: { x: -1439, y: -7580 },
                width: 11000,
                height: 9000,
            },
            // Interserrana corridor view (wide, shows Pharr + Laredo)
            interserrana: {
                center: { x: 161284, y: -244948 },
                width: 3673884,
                height: 1590992,
            },
        };

        class Camera {
            constructor(w, h) {
                this.canvasWidth = w;
                this.canvasHeight = h;
                this.centerWorld = { x: 9880, y: 382686 };
                this.zoom = 0.00043;  // Start zoomed out (MACRO)
                this.currentFrame = null;  // Track current semantic frame
                this._updateViewport();
            }

            _updateViewport() {
                const halfW = (this.canvasWidth / 2) / this.zoom;
                const halfH = (this.canvasHeight / 2) / this.zoom;
                this.viewportWorld = {
                    minX: this.centerWorld.x - halfW,
                    maxX: this.centerWorld.x + halfW,
                    minY: this.centerWorld.y - halfH,
                    maxY: this.centerWorld.y + halfH,
                };
            }

            worldToScreen(wx, wy) {
                return {
                    x: this.canvasWidth / 2 + (wx - this.centerWorld.x) * this.zoom,
                    y: this.canvasHeight / 2 - (wy - this.centerWorld.y) * this.zoom,
                };
            }

            screenToWorld(sx, sy) {
                return {
                    x: this.centerWorld.x + (sx - this.canvasWidth / 2) / this.zoom,
                    y: this.centerWorld.y - (sy - this.canvasHeight / 2) / this.zoom,
                };
            }

            metersToPixels(m) { return m * this.zoom; }

            pan(dx, dy) {
                this.centerWorld.x -= dx / this.zoom;
                this.centerWorld.y += dy / this.zoom;
                this._updateViewport();
            }

            setZoom(z) {
                this.zoom = Math.max(0.0002, Math.min(1.0, z));
                this._updateViewport();
            }

            zoomAt(factor, sx, sy) {
                const before = this.screenToWorld(sx, sy);
                this.zoom *= factor;
                this.zoom = Math.max(0.0002, Math.min(1.0, this.zoom));
                this._updateViewport();
                const after = this.screenToWorld(sx, sy);
                this.centerWorld.x += before.x - after.x;
                this.centerWorld.y += before.y - after.y;
                this._updateViewport();
            }

            // Smooth zoom to target
            zoomTo(targetZoom, duration = 500) {
                // Implemented via animation in frame loop
            }

            focusMacro() {
                // Center on network centroid, zoomed out to see corridors
                this.centerWorld = { x: 0, y: 80000 };  // Slightly north
                this.zoom = 0.0003;  // Zoomed out for macro view
                this._updateViewport();
            }

            focusLocal() {
                // Center on east corridor injection area
                this.centerWorld = { x: -8518, y: -5971 };
                this.zoom = 0.044355;
                this._updateViewport();
            }

            /**
             * Fit a world-space frame to the current viewport.
             * Computes zoom to ensure entire frame is visible with aspect preservation.
             * Letterboxing is intentional — no cropping, no distortion.
             *
             * @param {string} frameName - Key into WORLD_FRAMES
             * @returns {boolean} - True if frame was found and applied
             */
            fitToFrame(frameName) {
                const frame = WORLD_FRAMES[frameName];
                if (!frame) {
                    console.warn(`[Camera] Unknown frame: ${frameName}`);
                    return false;
                }

                // Compute aspect ratios
                const viewportAspect = this.canvasWidth / this.canvasHeight;
                const frameAspect = frame.width / frame.height;

                // Fit with letterboxing: scale uniformly until entire frame fits
                // If viewport is wider than frame: constrain by height
                // If viewport is taller than frame: constrain by width
                if (viewportAspect > frameAspect) {
                    // Viewport is wider — height is the constraint
                    this.zoom = this.canvasHeight / frame.height;
                } else {
                    // Viewport is taller — width is the constraint
                    this.zoom = this.canvasWidth / frame.width;
                }

                // Center on frame
                this.centerWorld = { x: frame.center.x, y: frame.center.y };
                this.currentFrame = frameName;
                this._updateViewport();
                return true;
            }

            /**
             * Re-fit current frame after resize.
             * Call this from window resize handler.
             */
            refitCurrentFrame() {
                if (this.currentFrame) {
                    this.fitToFrame(this.currentFrame);
                }
            }
        }

        // =====================================================================
        // TIME
        // =====================================================================

        class SimTime {
            constructor() {
                this.simTimeSeconds = 8 * 3600;
                this.paused = true;  // Start paused - use director action 'startSim' to begin
                // R key cycles: 0=normal, 1=slow (0.25x) — no speedup (breaks constant dt)
                this.speedMode = 0;
                this.speedModes = [
                    { name: 'NORMAL', mult: 1.0 },
                    { name: 'SLOW', mult: 0.25 },
                ];
            }

            get currentHour() { return Math.floor(this.simTimeSeconds / 3600) % 24; }
            get simTimeHours() { return this.simTimeSeconds / 3600; }

            // Use authoritative SIM_TIME_SCALE from FIELD, multiplied by speed mode
            // null mult = real-time (1:1), otherwise mult * SIM_TIME_SCALE
            get timeScale() {
                const mode = this.speedModes[this.speedMode];
                return mode.mult !== null ? mode.mult * ReynosaEastOverlay.SIM_TIME_SCALE : 1.0;
            }

            get speedModeName() {
                return this.speedModes[this.speedMode].name;
            }

            tick(dtReal) {
                // Advance sim time using authoritative scale
                // dtReal is in milliseconds
                if (!this.paused) {
                    let simDt = (dtReal / 1000) * this.timeScale;
                    // CAP: Match physics MAX_DT (120 substeps * 0.5s = 60 sim-seconds)
                    // Prevents clock from advancing faster than physics can process
                    const MAX_SIM_DT = 60;
                    if (simDt > MAX_SIM_DT) simDt = MAX_SIM_DT;
                    this.simTimeSeconds += simDt;
                }
            }

            setHour(h) { this.simTimeSeconds = h * 3600; }
            togglePause() { this.paused = !this.paused; }
            cycleSpeedMode() {
                this.speedMode = (this.speedMode + 1) % this.speedModes.length;
                return this.speedModes[this.speedMode];
            }
        }

        // =====================================================================
        // SETUP
        // =====================================================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const wrapper = document.getElementById('canvas-wrapper');
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;

        // WebGL canvas overlay for GPU-accelerated particle rendering
        const glCanvas = document.createElement('canvas');
        glCanvas.id = 'gl-canvas';
        glCanvas.width = canvas.width;
        glCanvas.height = canvas.height;
        glCanvas.style.position = 'absolute';
        glCanvas.style.left = '0';
        glCanvas.style.top = '0';
        glCanvas.style.pointerEvents = 'none';  // Pass clicks through to main canvas
        wrapper.appendChild(glCanvas);

        // Initialize WebGL particle renderer (shared between macro and local modes)
        const glRenderer = new ParticleRenderer(glCanvas);
        if (glRenderer.isAvailable()) {
            glRendererRef = glRenderer;  // Store for macroParticles to access
            setWebGLRenderer(glRenderer);
            // Also wire to macroParticles if already initialized
            if (macroParticles) {
                macroParticles.setWebGLRenderer(glRenderer);
                console.log('[INIT] WebGL wired to existing macroParticles');
            }
            console.log('[INIT] WebGL particle renderer enabled');
        } else {
            console.warn('[INIT] WebGL not available, using Canvas 2D fallback');
        }

        const camera = new Camera(canvas.width, canvas.height);
        // Set initial camera position using world-space frame
        camera.fitToFrame('opening');

        const time = new SimTime();

        // =====================================================================
        // DIRECTOR
        // =====================================================================

        const directorStatus = document.getElementById('director-status');

        // Macro month clock state (tracks annual flow during alienObserver)
        const macroMonthClock = document.getElementById('macro-month-clock');
        const MONTH_NAMES = ['ENE', 'FEB', 'MAR', 'ABR', 'MAY', 'JUN', 'JUL', 'AGO', 'SEP', 'OCT', 'NOV', 'DIC'];
        let macroMonthElapsedMs = 0;
        let macroMonthActive = false;
        const MACRO_PLAYBACK_MS = 95_000;  // ~95 seconds = alienObserver macro phase = 1 year

        function updateMacroMonthClock() {
            if (!macroMonthActive) return;
            const progress = Math.min(1, macroMonthElapsedMs / MACRO_PLAYBACK_MS);
            const monthIndex = Math.min(11, Math.floor(progress * 12));
            macroMonthClock.textContent = MONTH_NAMES[monthIndex];
        }

        const director = new Director(camera, time, {
            getPharrCoords: () => bundleLoaded ? getPharrWorldCoords() : { x: 0, y: 6000 },

            // World-space frame target getter
            // Computes { x, y, zoom } from frame name and current viewport dimensions
            getFrameTarget: (frameName) => {
                const frame = WORLD_FRAMES[frameName];
                if (!frame) {
                    console.warn(`[Director] Unknown frame: ${frameName}`);
                    return { x: 0, y: 0, zoom: 0.01 };
                }
                // Compute zoom to fit frame (same logic as camera.fitToFrame)
                const viewportAspect = camera.canvasWidth / camera.canvasHeight;
                const frameAspect = frame.width / frame.height;
                let zoom;
                if (viewportAspect > frameAspect) {
                    zoom = camera.canvasHeight / frame.height;
                } else {
                    zoom = camera.canvasWidth / frame.width;
                }
                return { x: frame.center.x, y: frame.center.y, zoom };
            },

            onPlay: () => {
                document.getElementById('btn-director-play').textContent = 'Pause';
                directorStatus.textContent = 'Playing...';
                directorStatus.style.color = '#4f4';
                // Start macro month clock
                macroMonthElapsedMs = 0;
                macroMonthActive = true;
                macroMonthClock.style.display = 'block';
                updateMacroMonthClock();
            },
            onPause: () => {
                document.getElementById('btn-director-play').textContent = 'Play';
                directorStatus.textContent = 'Paused';
                directorStatus.style.color = '#ff0';
            },
            onStop: () => {
                document.getElementById('btn-director-play').textContent = 'Play';
                directorStatus.textContent = 'Ready';
                directorStatus.style.color = '#666';
                // Stop macro month clock
                macroMonthActive = false;
                macroMonthClock.style.display = 'none';
                // Clear dimension stack on stop
                for (let i = 1; i <= 3; i++) {
                    const el = document.getElementById(`dim-${i}`);
                    if (el) {
                        el.classList.remove('visible', 'faded');
                        el.textContent = '';
                    }
                }
                const desc = document.getElementById('dim-1-desc');
                if (desc) {
                    desc.classList.remove('visible');
                    desc.innerHTML = '';
                }
            },
            onInstructionStart: (instr, idx) => {
                const total = director.script.length;
                directorStatus.textContent = `[${idx + 1}/${total}] ${instr.type}`;
            },
            onText: (text, centered) => {
                const el = document.getElementById('intro-text');
                el.innerHTML = text;
                el.style.display = 'block';
                el.style.opacity = '1';
                if (centered) {
                    el.classList.add('centered');
                } else {
                    el.classList.remove('centered');
                }
            },
            onFadeText: () => {
                const el = document.getElementById('intro-text');
                el.style.display = 'none';
            },
            onSimPause: (paused) => {
                document.getElementById('btn-pause').textContent = paused ? 'Resume' : 'Pause';
            },
            onMacroPause: (paused) => {
                if (macroParticles) {
                    macroParticles.paused = paused;
                    console.log(`[Director] Macro particles ${paused ? 'PAUSED' : 'RUNNING'}`);
                }
            },
            // Dimension stack callbacks
            onShowDim: (dim, text) => {
                const el = document.getElementById(`dim-${dim}`);
                if (el) {
                    el.textContent = text;
                    el.classList.add('visible');
                }
            },
            onFadeDims: (dims) => {
                for (const dim of dims) {
                    const el = document.getElementById(`dim-${dim}`);
                    if (el) {
                        el.classList.add('faded');
                    }
                }
            },
            onTypeDesc: (text) => {
                const el = document.getElementById('dim-1-desc');
                if (el) {
                    el.innerHTML += text;
                    el.classList.add('visible');
                }
            },
            onHideDims: () => {
                for (let i = 1; i <= 3; i++) {
                    const el = document.getElementById(`dim-${i}`);
                    if (el) {
                        el.classList.remove('visible', 'faded');
                        el.textContent = '';
                    }
                }
                const desc = document.getElementById('dim-1-desc');
                if (desc) {
                    desc.classList.remove('visible');
                    desc.innerHTML = '';
                }
                const stack = document.getElementById('dim-stack');
                if (stack) {
                    stack.classList.remove('shifted');
                }
            },
            onShiftDims: () => {
                const stack = document.getElementById('dim-stack');
                if (stack) {
                    stack.classList.add('shifted');
                }
            },
            // Orientation label callbacks
            // DEBUG: Sink labels re-enabled for gravity well visualization
            onShowSinkLabels: (topN = 5) => {
                const sinks = prepareSinkLabels(topN);
                orientationLabels.labels = [...orientationLabels.labels, ...sinks];
                orientationLabels.visible = true;
                orientationLabels.opacity = 1;
                console.log(`[Director] Added ${sinks.length} sink labels (DEBUG mode)`);
            },
            onShowSinkLabel: (rank) => {
                const allSinks = prepareSinkLabels(10);
                const labelToAdd = allSinks.find(l => l.rank === rank);
                if (labelToAdd) {
                    orientationLabels.labels.push(labelToAdd);
                    orientationLabels.visible = true;
                    orientationLabels.opacity = 1;
                }
            },
            onShowSourceLabels: (topN = 5) => {
                const sources = prepareSourceLabels(topN);
                // Append to existing labels (allows showing both at once)
                orientationLabels.labels = [...orientationLabels.labels, ...sources];
                orientationLabels.visible = true;
                orientationLabels.opacity = 1;
                console.log(`[Director] Added ${sources.length} source labels (total: ${orientationLabels.labels.length})`);
            },
            onShowPoeLabels: () => {
                const poeLabels = preparePoeLabels();
                orientationLabels.labels = poeLabels;
                orientationLabels.visible = true;
                orientationLabels.opacity = 1;
                console.log(`[Director] Showing ${poeLabels.length} POE labels`);
            },
            onShowPoeLabel: (poeId) => {
                const poeLabels = preparePoeLabels();
                const poeNameMap = {
                    'hidalgo_pharr': 'Reynosa-Pharr',
                    'laredo': 'Nuevo Laredo - Laredo'
                };
                const targetName = poeNameMap[poeId];
                const filtered = poeLabels.filter(l => l.name === targetName);
                orientationLabels.labels = filtered;
                orientationLabels.visible = true;
                orientationLabels.opacity = 1;
                console.log(`[Director] Showing POE label: ${poeId}`);
            },
            onHideLabels: () => {
                orientationLabels.visible = false;
                orientationLabels.labels = [];
                orientationLabels.opacity = 0;
                console.log('[Director] Hiding orientation labels');
            },
            onShowFramingSquare: (target = 'reynosa') => {
                framingSquare.bounds = calculateFramingBounds(target);
                framingSquare.target = target;
                framingSquare.visible = true;
                framingSquare.opacity = 1;
                console.log(`[Director] Showing framing square: ${target}`);
            },
            onHideFramingSquare: () => {
                framingSquare.visible = false;
                framingSquare.opacity = 0;
                console.log('[Director] Hiding framing square');
            },
            onShowInterserranaBox: () => {
                interserranaBox.visible = true;
                interserranaBox.opacity = 1;
                console.log('[Director] Showing interserrana box');
            },
            onHideInterserranaBox: () => {
                interserranaBox.visible = false;
                interserranaBox.opacity = 0;
                console.log('[Director] Hiding interserrana box');
            },
            onSetCorridorLabelPos: (corridor, x, y) => {
                if (x === null || y === null) {
                    setCorridorLabelOverride(corridor, null);
                } else {
                    setCorridorLabelOverride(corridor, { x, y });
                }
            },
            onShowLayerTransitionSquare: () => {
                layerTransitionSquare.visible = true;
                layerTransitionSquare.opacity = 1;
                console.log('[Director] Showing layer transition square');
            },
            onHideLayerTransitionSquare: () => {
                layerTransitionSquare.visible = false;
                layerTransitionSquare.opacity = 0;
                console.log('[Director] Hiding layer transition square');
            },
            onDevStartComparison: () => {
                // Ghost particles disabled - just switch to comparison mode
                devComparisonMode = true;
                console.log('[Director] DEV comparison mode ON (baseline routing active)');
            },
            onDevStopComparison: () => {
                if (macroParticles) {
                    macroParticles.devClearGhosts();
                    macroParticles.devColorOverride = null;  // Reset to normal colors
                }
                devComparisonMode = false;
                console.log('[Director] DEV comparison mode OFF');
            },
            onSnapToFrame: (target = 'reynosa') => {
                // Use world-space frame fitting (zoom computed from frame extent)
                if (camera.fitToFrame(target)) {
                    framingSquare.visible = false;
                    const frame = WORLD_FRAMES[target];
                    console.log(`[Director] Snapped to frame (${target}): center=(${frame.center.x}, ${frame.center.y}), computed zoom=${camera.zoom.toFixed(6)}`);
                } else {
                    // Fallback to reynosa if unknown frame
                    camera.fitToFrame('reynosa');
                    framingSquare.visible = false;
                    console.warn(`[Director] Unknown frame "${target}", fell back to reynosa`);
                }
                // Force LOCAL_FIELD for local frames (bypasses zoom threshold)
                const localFrames = ['reynosa', 'localSimIntro', 'scenarioRun', 'twinspan'];
                if (localFrames.includes(target)) {
                    currentZoomState = ZoomState.LOCAL_FIELD;
                    transitionProgress = 1;
                    if (macroParticles) macroParticles.paused = true;
                    console.log(`[Director] Forced LOCAL_FIELD state for frame: ${target}`);
                }
            },
            onStartSim: () => {
                // Start the simulation (unpause)
                time.paused = false;
                const pauseBtn = document.getElementById('btn-pause');
                if (pauseBtn) pauseBtn.textContent = 'Pause';
                console.log('[Director] Simulation STARTED');
            },
            onHighlightCorridors: (poes, equalBrightness = false) => {
                // Activate corridor highlight mode with magenta hierarchy (render-only, no camera move)
                // poes[0] = primary, poes[1] = secondary
                // equalBrightness = true: both at full magenta; false: secondary at 0.7 brightness
                if (macroParticles && poes.length >= 2) {
                    macroParticles.setCorridorHighlight(poes[0], poes[1], equalBrightness);
                }
                console.log(`[Director] Corridor highlight: ${poes[0]}, ${poes[1]}, equalBrightness=${equalBrightness}`);
            },
            onClearCorridorHighlight: () => {
                // Restore normal particle rendering
                if (macroParticles) {
                    macroParticles.clearCorridorHighlight();
                }
                console.log('[Director] Corridor highlight cleared');
            },
            onHideNonHighlighted: () => {
                if (macroParticles) {
                    macroParticles.hideNonHighlighted();
                }
            },
            onShowNonHighlighted: () => {
                if (macroParticles) {
                    macroParticles.showNonHighlighted();
                }
            },
            onDimNonHighlighted: (dimAlpha, highlightAlpha) => {
                if (macroParticles) {
                    macroParticles.dimNonHighlighted(dimAlpha, highlightAlpha);
                }
            },
            onSetCorridorColor: (poe, color) => {
                if (macroParticles) {
                    macroParticles.setCorridorColor(poe, color);
                }
            },
            onOverlay: (text, position, style, indent = 0, treeType = null, colorClass = null) => {
                const container = document.getElementById('telemetry-overlay');
                if (!container) return;
                const line = document.createElement('div');
                line.className = 'telemetry-line';
                if (indent > 0) line.classList.add(`indent-${indent}`);
                if (treeType) line.classList.add(treeType);  // 'tree', 'tree-last', 'tree-cont'
                if (colorClass) line.classList.add(colorClass);  // Add color class for mode-synced coloring
                line.textContent = text;
                container.appendChild(line);
                container.style.display = 'block';
            },
            onClearOverlays: () => {
                const container = document.getElementById('telemetry-overlay');
                if (container) {
                    container.innerHTML = '';
                    container.style.display = 'none';
                    container.classList.remove('state-mode', 'source-mode');  // Reset color modes
                }
            },
            onUpdateLiveOverlay: () => {
                // Update the first line (live counter) with current mass in system
                const container = document.getElementById('telemetry-overlay');
                if (!container || !container.firstChild) return;
                const massInSystemT = getLiveMassInSystemT();
                container.firstChild.textContent = `${massInSystemT.toFixed(0)} t en el sistema`;
            },
            onSetScenarioAlpha: (alpha) => {
                // Update overlay layer
                setScenarioAlpha(alpha);
                // Update macro particle layer POE distribution (existing particles keep routing)
                if (macroParticles) {
                    macroParticles.setScenarioAlpha(alpha);
                    macroParticles.updateWeights(segId => getInterpolatedWeight(segId, alpha));
                }
                macroAlpha = alpha;
                macroTargetAlpha = alpha;
                console.log(`[Director] Scenario alpha: ${alpha.toFixed(3)}`);
            },

            onSwitchToLayerB: () => {
                // Regime switch: Layer A (geometry) → Layer B (queue equilibrium)
                // Updates weights and POE distributions only — does NOT affect overlay scenario
                if (macroParticles) {
                    // Update segment weights to Layer B (α=1)
                    macroParticles.updateWeights(segId => getInterpolatedWeight(segId, 1.0));
                    // Update POE distribution for particle branching
                    macroParticles.setScenarioAlpha(1.0);
                }
                // Update state variables for consistency
                macroAlpha = 1.0;
                macroTargetAlpha = 1.0;
                console.log('[Director] Regime switch: Layer A → Layer B (queue equilibrium)');
            },
            onSetPoeMode: (mode) => {
                // Switch POE distribution for particle coloring (independent of routing)
                // mode: 'baseline' = all particles get baseline POEs
                // mode: 'interserrana' = particles get interserrana POEs (at α≥0.5)
                if (!macroParticles) return;
                if (mode === 'baseline') {
                    // Both slots = baseline, so all new particles get baseline POEs
                    macroParticles.setScenarioPoeDistributions(
                        _storedBaselinePoeDistribution,
                        _storedBaselinePoeDistribution
                    );
                    console.log('[Director] POE mode: baseline (both slots = baseline)');
                } else if (mode === 'interserrana') {
                    // baseline→interserrana, use α≥0.5 for interserrana POEs
                    macroParticles.setScenarioPoeDistributions(
                        _storedBaselinePoeDistribution,
                        _storedInterserranaPoeDistribution
                    );
                    macroParticles.setScenarioAlpha(1.0);  // Ensure α=1 so new particles use interserrana
                    console.log('[Director] POE mode: interserrana (α=1 → interserrana POEs)');
                }
            },
            onStartQueuePhase: () => {
                if (queueTimeSeries) {
                    queueTimeSeries.visible = true;
                }
                if (macroParticles && queueData) {
                    macroParticles.setQueueMode(true, queueData["0"]);
                }
                console.log('[Director] Queue phase started');
            },
            onSetQueueHour: (hour) => {
                if (queueTimeSeries) {
                    queueTimeSeries.setHour(hour);
                }
                if (macroParticles && queueData) {
                    macroParticles.setQueueMode(true, queueData[String(hour)]);
                }
                console.log(`[Director] Queue hour: ${hour}`);
            },
            onEndQueuePhase: () => {
                if (queueTimeSeries) {
                    queueTimeSeries.visible = false;
                }
                if (macroParticles) {
                    macroParticles.setQueueMode(false, null);
                }
                console.log('[Director] Queue phase ended');
            },
            onSetPoeOverlay: (enabled, options) => {
                if (poeNodeLayer) {
                    poeNodeLayer.setEnabled(enabled, options);
                }
                // Bleed visualization REPLACES the queue time series
                if (enabled && queueTimeSeries) {
                    queueTimeSeries.visible = false;
                }
                console.log(`[Director] POE overlay: ${enabled ? 'ON' : 'OFF'}`, options);
            },
            // Local sim controls (FIELD layer)
            onSetParticleColorMode: (mode) => {
                // Set particle color mode by cycling until we reach the target mode
                // Mode: 0=OFF, 1=STALL, 2=SOURCE, 3=STATE
                let cycles = 0;
                while (getParticleColorMode() !== mode && cycles < 4) {
                    cycleParticleColorMode();
                    cycles++;
                }
                console.log(`[Director] Particle color mode: ${mode} (cycled ${cycles}x)`);

                // Sync telemetry text colors with particle mode
                const container = document.getElementById('telemetry-overlay');
                if (container) {
                    container.classList.remove('state-mode', 'source-mode');
                    if (mode === 3) container.classList.add('state-mode');
                    else if (mode === 2) container.classList.add('source-mode');
                }
            },
            onTogglePhysicsDebug: () => {
                // Call local togglePhysicsDebug function (defined in testBundle scope)
                togglePhysicsDebug();
            },
            onCycleDebugLayer: () => {
                // Call local cycleDebugLayer function (defined in testBundle scope)
                cycleDebugLayer();
            },
            onStartLocalSimIntro: async () => {
                console.log('[Director] onStartLocalSimIntro ENTERED');
                // Load local sim if not already loaded
                await loadLocalSim();
                console.log('[Director] loadLocalSim() COMPLETED, now calling getModelSpec()');
                // Get model spec from local sim
                const modelSpec = getModelSpec();
                // Load and play localSimIntro script + final inovus beat
                const localScript = Scripts.localSimIntro(modelSpec);
                const finalBeats = [
                    { type: 'showFramingSquare', target: 'inovus' },
                    { type: 'wait', duration: 3000 },
                    { type: 'hideFramingSquare' },
                    { type: 'snapToFrame', target: 'inovus' },
                    { type: 'wait', duration: 5000 },
                    // Telemetry stays visible - no showLiveLogs
                ];
                director.load([...localScript, ...finalBeats]);
                director.play();
                console.log('[Director] Local sim intro started');
            },

            onPreloadLocalSim: () => {
                // Fire and forget - start loading in background
                // loadLocalSim() is idempotent, so safe to call multiple times
                loadLocalSim();
                console.log('[Director] Preloading local sim in background...');
            },

            onStartLocalSimIntroThenScenarios: (() => {
                let inProgress = false;  // Re-entry guard for async callback
                return async () => {
                    if (inProgress) return;
                    inProgress = true;

                    // Load local sim if not already loaded (should be instant if preloaded)
                    await loadLocalSim();

                    // Get model spec from local sim
                    const modelSpec = getModelSpec();
                    // Build combined script: localSimIntro + switchToInterserrana + scenarioComparison
                    const localScript = Scripts.localSimIntro(modelSpec);
                    const scenarioScript = Scripts.scenarioComparison();
                    const combinedScript = [
                        ...localScript,
                        { type: 'switchToInterserrana' },  // Switch bundles between phases
                        ...scenarioScript
                    ];
                    director.load(combinedScript);
                    director.play();
                    console.log('[Director] Local sim intro + scenario comparison started');

                    inProgress = false;  // Allow future calls (e.g., if script loops back)
                };
            })(),

            onSwitchToInterserrana: () => {
                // Switch weight maps from LAYER_A→baseline to baseline→interserrana for scenario comparison
                if (_storedBaselineBundle && _storedInterserranaBundle) {
                    loadScenarioPairBundles(_storedBaselineBundle, _storedInterserranaBundle);
                    loadWeightMaps(_storedBaselineBundle, _storedInterserranaBundle, { hs2Filter: null, poeFilter: null });

                    // Update local field sim injection ratios (corridor split)
                    updateInjectionRatios(_storedBaselineBundle, _storedInterserranaBundle);

                    // POE distributions for macro particles - reuse stored distributions
                    if (macroParticles) {
                        macroParticles.setScenarioPoeDistributions(
                            _storedBaselinePoeDistribution,
                            _storedInterserranaPoeDistribution
                        );
                    }
                    console.log('[Director] Switched to baseline→interserrana for scenario comparison');
                }
            },

            // ═══════════════════════════════════════════════════════════
            // SCENARIO COMPARISON CALLBACKS
            // ═══════════════════════════════════════════════════════════

            onScenarioIntervention: (name, intervention) => {
                const labelEl = document.getElementById('scenario-label');
                const interventionEl = document.getElementById('scenario-intervention');
                if (labelEl) {
                    labelEl.textContent = name;
                    labelEl.style.display = 'block';
                }
                if (interventionEl) {
                    interventionEl.textContent = intervention || '';
                    interventionEl.style.display = intervention ? 'block' : 'none';
                }
                console.log(`[Director] Scenario: ${name}${intervention ? ' — ' + intervention : ''}`);
            },

            onVisualChange: (effect) => {
                console.log(`[Director] Visual change: ${effect}`);
                switch (effect) {
                    case 'cbpLanesDouble':
                        // Enable Twin Span (same as button click)
                        twinSpanTargetAlpha = 1;
                        twinSpanRampStartTime = performance.now();
                        twinSpanRampStartAlpha = twinSpanAlpha;
                        syncTwinspanButtons(true);
                        console.log('[Twin Span] Target α:', twinSpanTargetAlpha);
                        break;
                    case 'interserranaRoute':
                        // TODO: Highlight Interserrana route
                        break;
                    case 'inovusFull':
                        // Enable INOVUS lots (same as button click)
                        if (!ReynosaEastOverlay.isPhasesAsLots()) {
                            ReynosaEastOverlay.togglePhasesAsLots();
                            syncInovusButtons(true);
                            console.log('[INOVUS] Phases as lots ENABLED');
                        }
                        break;
                }
            },

            onClockMontageStart: (days) => {
                const dayEl = document.getElementById('montage-day');
                if (dayEl) {
                    dayEl.style.display = 'block';
                    dayEl.textContent = `DÍA 1 / ${days}`;
                }
                // Don't show separate montage-clock - we drive the main sim clock instead
                console.log(`[Director] Clock montage started: ${days} days`);
            },

            onClockMontageDay: (day, totalDays, hour) => {
                const dayEl = document.getElementById('montage-day');
                if (dayEl) {
                    dayEl.textContent = `DÍA ${day} / ${totalDays}`;
                }
                // Drive main sim clock (updates hourValue display via render loop)
                time.setHour(hour);
                // CONDITION A: Update metrics based on sim-time (day, hour)
                // This is the SINGLE SOURCE OF TRUTH for metric updates
                updateMetricsReplayAtHour(day, hour);

                // Update replay lot particles from sampled data
                if (replayState.active && replayState.scenarioName) {
                    const simTimeSeconds = (day - 1) * 86400 + hour * 3600;
                    const lotFillRatios = getInterpolatedLotFillRatios(replayState.scenarioName, simTimeSeconds);
                    if (lotFillRatios) {
                        updateReplayLotParticles(lotFillRatios);
                    }
                }
            },

            onClockMontageEnd: () => {
                const dayEl = document.getElementById('montage-day');
                if (dayEl) dayEl.style.display = 'none';
                // Clear replay lot particles and trails
                clearReplayLotParticles();
                clearParticleTrails();
                // Final update at end of sim-time
                if (replayState.active) {
                    updateMetricsReplayAtHour(replayState.totalDays, 24);
                }
                console.log('[Director] Clock montage ended');
            },

            onStartReplay: (scenarioName, totalDays) => {
                startMetricsReplay(scenarioName, totalDays);
            },

            onCommitToLedger: (scenarioName) => {
                commitToLedger(scenarioName);
            },

            onResetLedger: () => {
                resetLedger();
            },

            onSetReplayMode: (enabled, timeScale = 1) => {
                // Wire to overlay REPLAY_MODE flag
                setReplayMode(enabled, timeScale);
                // Enable/disable particle trails for motion visualization at high speed
                setTrailsEnabled(enabled);
                if (!enabled) clearParticleTrails();
                // Update UI indicator
                setReplayModeIndicator(enabled, timeScale);
                console.log(`[Director] Replay mode: ${enabled ? 'ON' : 'OFF'}, timeScale=${timeScale}x, trails=${enabled}`);
            },

            onShowMetrics: (scenarioName) => {
                showScenarioMetrics(scenarioName);
            },

            onClearMetrics: () => {
                clearScenarioMetrics();
            },

            onResetSim: () => {
                // Reset sim to clean state after replay corrupted physics
                reset();
                console.log('[Director] Sim reset to clean state');
            },

            onShowComparisonTable: () => {
                showComparisonTable();
            },

            onSetMacroParticleDensity: (multiplier) => {
                // Boost macro particle emission rate to show increased demand
                if (macroParticles && macroParticles.setDensityMultiplier) {
                    macroParticles.setDensityMultiplier(multiplier);
                    console.log(`[Director] Macro particle density: ${multiplier}x`);
                } else {
                    console.warn('[Director] macroParticles.setDensityMultiplier not available');
                }
            },
            onForceMacroRender: (enabled) => {
                // Override zoom-based rendering to show macro layer
                forceMacroRender = enabled;
                console.log(`[Director] Force macro render: ${enabled ? 'ON' : 'OFF'}`);
                // Unpause macro when forcing render, re-pause when disabling (if in local field)
                if (macroParticles) {
                    if (enabled) {
                        macroParticles.paused = false;
                    } else if (currentZoomState === ZoomState.LOCAL_FIELD) {
                        macroParticles.paused = true;
                    }
                }
            },
            onEnterLocalField: () => {
                // Explicitly enter LOCAL_FIELD state (bypasses zoom threshold)
                currentZoomState = ZoomState.LOCAL_FIELD;
                transitionProgress = 1;
                forceMacroRender = false;
                if (macroParticles) macroParticles.paused = true;
                console.log('[Director] Entered LOCAL_FIELD (explicit)');
            },
            onShowLiveLogs: () => {
                const panel = document.getElementById('live-logs');
                panel.style.display = 'block';
                console.log('[Director] Live logs panel ON');
                // Start polling for new logs
                startLiveLogPolling();
            },
            onHighlightLots: () => {
                lotHighlightActive = true;
                setHideParticles(true);
                const debug = getPhysicsDebugData();
                const lotCellCount = debug?.regionMap ? [...debug.regionMap].filter(r => r === debug.REGION_LOT).length : 0;
                console.log(`[Director] Lot highlight ON — ${lotCellCount} lot cells in regionMap`);
            },
            onClearLotHighlight: () => {
                lotHighlightActive = false;
                setHideParticles(false);
                console.log('[Director] Lot highlight OFF');
            },
            onSetCommuterDebug: (enabled) => {
                // Set commuter debug to specific state (not toggle)
                const current = isShowingCommuterDebug();
                if (current !== enabled) {
                    toggleCommuterDebug();
                }
                console.log(`[Director] Commuter debug ${enabled ? 'ON' : 'OFF'}`);
            },
            onSetCommuterHeatmap: (enabled) => {
                setCommuterHeatmap(enabled);
                console.log(`[Director] Commuter heatmap ${enabled ? 'ON' : 'OFF'}`);
            },
            onShowHourlyTable: () => {
                populateHourlyTable(rawBundle);
                console.log('[Director] Hourly table shown');
            },
            onHideHourlyTable: () => {
                hideHourlyTable();
                console.log('[Director] Hourly table hidden');
            },
        });

        // =====================================================================
        // ORIENTATION LABELS (Sources & Sinks)
        // =====         =======================================================

        // State for orientation labels
        const orientationLabels = {
            visible: false,
            type: null,  // 'sinks' or 'sources'
            labels: [],  // [{ name, rank, screenX, screenY }]
            opacity: 0,
        };

        // City name normalization (Title Case → snake_case for coordinate lookup)
        function normalizeCityName(name) {
            return name.toLowerCase().replace(/ /g, '_');
        }

        // =====================================================================
        // SCENARIO METRICS
        // =====================================================================

        let scenarioMetricsData = null;

        // Map Director scenario labels to results file scenario names (1:1, self-documenting)
        const SCENARIO_NAME_MAP = {
            'Baseline': 'Baseline',
            'Twinspan': 'Twinspan',
            'InovusTwinspan': 'InovusTwinspan',
            'InovusTwinspanInterserrana': 'InovusTwinspanInterserrana',
        };

        async function loadScenarioMetrics() {
            const res = await fetch('../tracker/results/260113_1138/comparison_Baseline_Twinspan_Inovus_InovusTwinspan_InovusTwinspanInterserrana_7d.json');
            scenarioMetricsData = await res.json();
            console.log('[Scenario Metrics] Loaded from tracker:', scenarioMetricsData.meta);
        }

        function getScenarioSummary(scenarioName) {
            if (!scenarioMetricsData || !scenarioMetricsData.scenarios) return null;
            const mappedName = SCENARIO_NAME_MAP[scenarioName] || scenarioName;
            const scenario = scenarioMetricsData.scenarios.find(s => s.scenarioName === mappedName);
            return scenario ? scenario.summary : null;
        }

        function getBaselineSummary() {
            return getScenarioSummary('Baseline');
        }

        /**
         * Get interpolated lotFillRatios for a given scenario and sim-time.
         * Looks up the two nearest samples and linearly interpolates between them.
         *
         * @param {string} scenarioName - Scenario name (will be mapped via SCENARIO_NAME_MAP)
         * @param {number} simTimeSeconds - Sim-time in seconds (day * 86400 + hour * 3600)
         * @returns {number[]|null} - Array of fill ratios per lot, or null if not available
         */
        function getInterpolatedLotFillRatios(scenarioName, simTimeSeconds) {
            if (!scenarioMetricsData || !scenarioMetricsData.scenarios) return null;

            const mappedName = SCENARIO_NAME_MAP[scenarioName] || scenarioName;
            const scenario = scenarioMetricsData.scenarios.find(s => s.scenarioName === mappedName);
            if (!scenario || !scenario.samples || scenario.samples.length === 0) return null;

            const samples = scenario.samples;

            // Find surrounding samples
            let before = null, after = null;
            for (let i = 0; i < samples.length; i++) {
                if (samples[i].t <= simTimeSeconds) {
                    before = samples[i];
                }
                if (samples[i].t >= simTimeSeconds && !after) {
                    after = samples[i];
                    break;
                }
            }

            // Edge cases
            if (!before && !after) return null;
            if (!before) return after.lotFillRatios || null;
            if (!after) return before.lotFillRatios || null;
            if (!before.lotFillRatios || !after.lotFillRatios) return null;

            // Same sample
            if (before.t === after.t) return before.lotFillRatios;

            // Linear interpolation
            const t = (simTimeSeconds - before.t) / (after.t - before.t);
            const result = [];
            const len = Math.min(before.lotFillRatios.length, after.lotFillRatios.length);
            for (let i = 0; i < len; i++) {
                result[i] = before.lotFillRatios[i] + t * (after.lotFillRatios[i] - before.lotFillRatios[i]);
            }
            return result;
        }

        function showScenarioMetrics(scenarioName) {
            const container = document.getElementById('scenario-metrics');
            if (!container) return;

            const summary = getScenarioSummary(scenarioName);
            const baseline = getBaselineSummary();

            if (!summary) {
                console.warn(`[Scenario Metrics] No data for ${scenarioName}`);
                container.innerHTML = '<div class="metric-line"><span class="metric-label">No data available</span></div>';
                container.style.display = 'block';
                return;
            }

            // ═══════════════════════════════════════════════════════════════
            // EPHEMERAL SCENARIO BLOCK (A)
            // Role: live system state. Absolute units only. No deltas, no per-truck.
            // ═══════════════════════════════════════════════════════════════
            container.innerHTML = `
                <div class="metric-line">
                    <span class="metric-label">Carga total de demora</span>
                    <span class="metric-value">${Math.round(summary.truckHoursLost_final)} camión-h</span>
                </div>
                <div class="metric-line breakdown">
                    <span class="metric-label">Congestión vial</span>
                    <span class="metric-value">${Math.round(summary.truckHoursLostCongestion_final)} camión-h</span>
                </div>
                <div class="metric-line breakdown last">
                    <span class="metric-label">Espera en patios</span>
                    <span class="metric-value">${Math.round(summary.truckHoursLostLotWait_final)} camión-h</span>
                </div>
                <div class="metric-line" style="margin-top: 12px;">
                    <span class="metric-label">Carriles CBP activos</span>
                    <span class="metric-value">${summary.cbpLanesInUse_mean.toFixed(1)} / 7</span>
                </div>
                <div class="metric-line">
                    <span class="metric-label">Cola CBP promedio</span>
                    <span class="metric-value">${Math.round(summary.sinkQueueCount_mean)} camiones</span>
                </div>
            `;
            container.style.display = 'block';
        }

        function clearScenarioMetrics() {
            const container = document.getElementById('scenario-metrics');
            if (container) {
                container.innerHTML = '';
                container.style.display = 'none';
            }
            // Also hide scenario label
            const labelEl = document.getElementById('scenario-label');
            const interventionEl = document.getElementById('scenario-intervention');
            if (labelEl) labelEl.style.display = 'none';
            if (interventionEl) interventionEl.style.display = 'none';
        }

        // FIXED NARRATIVE ORDER — scenarios are additive layers, not alternatives
        const SCENARIO_NARRATIVE_ORDER = [
            { key: 'Baseline', display: 'Baseline' },
            { key: 'Twinspan', display: 'Twinspan' },
            { key: 'InovusTwinspan', display: 'Twinspan + Inovus' },
            { key: 'InovusTwinspanInterserrana', display: 'Twinspan + Inovus + Interserrana' },
        ];

        function showComparisonTable() {
            const container = document.getElementById('comparison-table');
            if (!container) return;

            if (!scenarioMetricsData || !scenarioMetricsData.scenarios) {
                container.innerHTML = '<div style="color:#888;">No data available</div>';
                container.style.display = 'block';
                return;
            }

            const baseline = getBaselineSummary();

            // Build rows in FIXED narrative order (not sorted by performance)
            const orderedScenarios = SCENARIO_NARRATIVE_ORDER
                .map(o => {
                    const s = scenarioMetricsData.scenarios.find(sc => sc.scenarioName === o.key);
                    return s ? { ...s, displayName: o.display } : null;
                })
                .filter(s => s !== null);

            // Helper: format delta as subtext
            function formatDelta(value, baselineValue) {
                if (baselineValue === undefined || baselineValue === 0) return '';
                const d = value - baselineValue;
                if (Math.abs(d) < 0.5) return '';
                const sign = d >= 0 ? '+' : '';
                const cls = d < 0 ? 'negative' : 'positive';
                return `<span class="delta ${cls}">${sign}${Math.round(d)}</span>`;
            }

            // ═══════════════════════════════════════════════════════════════
            // PERSISTENT COMPARISON TABLE (B)
            // Role: comparative judgment. Normalized per-truck metrics. Deltas allowed.
            // ═══════════════════════════════════════════════════════════════

            // Helper: format per-truck delta
            function formatPerTruckDelta(value, baselineValue) {
                if (baselineValue === undefined || baselineValue === null) return '';
                const d = value - baselineValue;
                if (Math.abs(d) < 0.001) return '';
                const sign = d >= 0 ? '+' : '';
                const cls = d < 0 ? 'negative' : 'positive';
                return `<span class="delta ${cls}">${sign}${d.toFixed(2)}</span>`;
            }

            // PRIMARY: Per-truck delay metrics (what we rank by)
            const primaryRows = orderedScenarios.map(s => {
                const isBaseline = s.scenarioName === 'Baseline';
                const avgDelay = s.summary.avgDelayPerTruck ?? 0;
                const avgCongestion = s.summary.avgCongestionPerTruck ?? 0;
                const avgCbpQueue = s.summary.avgBridgeQueuePerTruck ?? 0;
                const avgLotWait = s.summary.avgLotWaitPerTruck ?? 0;

                // Deltas vs baseline (allowed here per spec)
                const delayDelta = isBaseline ? '' : formatPerTruckDelta(avgDelay, baseline?.avgDelayPerTruck);
                const congestionDelta = isBaseline ? '' : formatPerTruckDelta(avgCongestion, baseline?.avgCongestionPerTruck);
                const cbpQueueDelta = isBaseline ? '' : formatPerTruckDelta(avgCbpQueue, baseline?.avgBridgeQueuePerTruck);
                const lotWaitDelta = isBaseline ? '' : formatPerTruckDelta(avgLotWait, baseline?.avgLotWaitPerTruck);

                return `<div class="table-row${isBaseline ? ' baseline' : ''}">
                    <span>${s.displayName}</span>
                    <span>${avgDelay.toFixed(2)}${delayDelta}</span>
                    <span>${avgCongestion.toFixed(2)}${congestionDelta}</span>
                    <span>${avgCbpQueue.toFixed(3)}${cbpQueueDelta}</span>
                    <span>${avgLotWait.toFixed(3)}${lotWaitDelta}</span>
                </div>`;
            }).join('');

            // STRUCTURAL CONTEXT: Non-ranked, for interpretation
            const contextRows = orderedScenarios.map(s => {
                const isBaseline = s.scenarioName === 'Baseline';
                const injection = s.summary.injectedKg_final ? Math.round(s.summary.injectedKg_final / 1000) : '—';
                const cbpLanes = s.summary.cbpLanesInUse_mean !== undefined ? s.summary.cbpLanesInUse_mean.toFixed(1) : '—';
                const lotCapacity = s.summary.totalLotCapacityKg ? (s.summary.totalLotCapacityKg / 1e6).toFixed(1) : '—';
                return `<div class="table-row${isBaseline ? ' baseline' : ''}">
                    <span>${s.displayName}</span>
                    <span>${injection}</span>
                    <span>${cbpLanes}</span>
                    <span>${lotCapacity}</span>
                </div>`;
            }).join('');

            container.innerHTML = `
                <div class="tier-label">Demora por camión (h/camión)</div>
                <div class="table-header">
                    <span>Escenario</span>
                    <span>Demora total</span>
                    <span>Congestión</span>
                    <span>Cola CBP</span>
                    <span>Patios</span>
                </div>
                ${primaryRows}

                <div class="tier-label">Contexto estructural</div>
                <div class="table-header">
                    <span>Escenario</span>
                    <span>Inyección (t)</span>
                    <span>CBP prom</span>
                    <span>Cap patios (Mt)</span>
                </div>
                ${contextRows}
            `;
            container.style.display = 'block';

            // Hide the scenario label when showing table
            const labelEl = document.getElementById('scenario-label');
            const interventionEl = document.getElementById('scenario-intervention');
            if (labelEl) labelEl.style.display = 'none';
            if (interventionEl) interventionEl.style.display = 'none';
        }

        // Load scenario metrics on startup
        loadScenarioMetrics();

        // =====================================================================
        // METRICS REPLAY (temporal projection from terminal state)
        // =====================================================================
        //
        // MECHANICAL CONSTRAINTS:
        //
        //   A. SIM-TIME IS AUTHORITATIVE
        //      - Counters update on sim-hour ticks, not animation frames
        //      - clockMontageDay(day, hour) is the SINGLE SOURCE OF TRUTH
        //      - Metric interpolation keys off (elapsedSimHours / totalSimHours)
        //
        //   B. UI LOCKOUT DURING REPLAY
        //      - Scenario toggles: disabled
        //      - Camera jumps: disabled
        //      - Controls: greyed out
        //      - Banner: "SIMULATION RUNNING — DAY X / 7"
        //      - "You can't touch it while it's running."
        //
        //   C. DISCRETE ACCUMULATION
        //      - Metrics advance in stepwise increments
        //      - No continuous easing per frame
        //      - Plateaus are allowed
        //      - Overshoot is FORBIDDEN
        //
        //   D. PARTICLES ARE SUBORDINATE
        //      - Particles may: move, drift, breathe
        //      - Particles may NOT: form new queues, resolve congestion,
        //        contradict counter trends
        //      - COUNTERS DEFINE TRUTH. PARTICLES PROVIDE CONTEXT.
        //
        // =====================================================================

        // Replay state
        let replayState = {
            active: false,
            scenarioName: null,
            summary: null,
            baseline: null,
            totalDays: 7,
            totalSimHours: 168,  // 7 * 24
            lastSimHour: -1,     // Track discrete hour ticks
        };

        // Ledger state (cumulative, irreversible)
        let ledgerRows = [];

        /**
         * Start metrics replay for a scenario.
         * Enables UI lockout (CONDITION B).
         * Counters begin at 0 and step discretely to final values.
         */
        function startMetricsReplay(scenarioName, totalDays = 7) {
            const summary = getScenarioSummary(scenarioName);
            const baseline = getBaselineSummary();

            if (!summary) {
                console.warn(`[Replay] No data for ${scenarioName}`);
                return;
            }

            replayState = {
                active: true,
                scenarioName,
                summary,
                baseline,
                totalDays,
                totalSimHours: totalDays * 24,
                lastSimHour: -1,
            };

            // Initialize display at hour 0
            updateMetricsReplayAtHour(0, 0);
            console.log(`[Replay] Started: ${scenarioName}, ${totalDays} days (${totalDays * 24} sim-hours)`);
        }

        /**
         * Update metrics based on sim-time (CONDITION A).
         * Called from onClockMontageDay(day, hour).
         * This is the SINGLE SOURCE OF TRUTH for metric updates.
         *
         * @param {number} day - Current sim day (1-indexed)
         * @param {number} hour - Current sim hour (0-23)
         */
        function updateMetricsReplayAtHour(day, hour) {
            if (!replayState.active) return;

            const { summary, baseline, scenarioName, totalDays, totalSimHours, lastSimHour } = replayState;

            // Calculate elapsed sim-hours (CONDITION A)
            const elapsedSimHours = (day - 1) * 24 + hour;

            // CONDITION C: Only update on discrete hour boundaries
            // Skip if we haven't advanced at least 1 sim-hour
            if (elapsedSimHours <= lastSimHour && lastSimHour >= 0) {
                return;
            }
            replayState.lastSimHour = elapsedSimHours;

            // Calculate progress as ratio of sim-hours (CONDITION A)
            // Use floor to ensure discrete steps (CONDITION C)
            const progress = Math.min(1, elapsedSimHours / totalSimHours);

            // CONDITION C: Discrete accumulation — no smoothstep, just linear from sim-time
            // Plateaus allowed, overshoot forbidden
            const t = Math.min(1, progress);

            const truckHoursLost = summary.truckHoursLost_final * t;
            const truckHoursLostCongestion = summary.truckHoursLostCongestion_final * t;
            const truckHoursLostLotWait = summary.truckHoursLostLotWait_final * t;

            // Mean metrics stay constant (they're averages, not cumulative)
            const cbpLanesInUse = summary.cbpLanesInUse_mean;
            const sinkQueueCount = summary.sinkQueueCount_mean;

            const container = document.getElementById('scenario-metrics');
            if (!container) return;

            // ═══════════════════════════════════════════════════════════════
            // EPHEMERAL SCENARIO BLOCK (A) - Replay version
            // Role: live system state. Absolute units only. No deltas, no per-truck.
            // ═══════════════════════════════════════════════════════════════
            container.innerHTML = `
                <div class="metric-line">
                    <span class="metric-label">Carga total de demora</span>
                    <span class="metric-value">${Math.round(truckHoursLost)} camión-h</span>
                </div>
                <div class="metric-line breakdown">
                    <span class="metric-label">Congestión vial</span>
                    <span class="metric-value">${Math.round(truckHoursLostCongestion)} camión-h</span>
                </div>
                <div class="metric-line breakdown last">
                    <span class="metric-label">Espera en patios</span>
                    <span class="metric-value">${Math.round(truckHoursLostLotWait)} camión-h</span>
                </div>
                <div class="metric-line" style="margin-top: 12px;">
                    <span class="metric-label">Carriles CBP activos</span>
                    <span class="metric-value">${cbpLanesInUse.toFixed(1)} / 7</span>
                </div>
                <div class="metric-line">
                    <span class="metric-label">Cola CBP promedio</span>
                    <span class="metric-value">${Math.round(sinkQueueCount)} camiones</span>
                </div>
            `;
            container.style.display = 'block';
        }

        /**
         * CONDITION B: UI lockout during replay.
         * "You can't touch it while it's running."
         */
        function setReplayLockout(locked, currentDay = 1, totalDays = 7) {
            const banner = document.getElementById('replay-lockout-banner');
            const controlsOverlay = document.getElementById('controls-lockout-overlay');

            if (locked) {
                // Show lockout banner
                if (banner) {
                    banner.textContent = `SIMULATION RUNNING — DAY ${currentDay} / ${totalDays}`;
                    banner.style.display = 'block';
                }
                // Grey out controls
                if (controlsOverlay) {
                    controlsOverlay.style.display = 'block';
                }
                // Disable keyboard shortcuts
                document.body.classList.add('replay-locked');
            } else {
                if (banner) banner.style.display = 'none';
                if (controlsOverlay) controlsOverlay.style.display = 'none';
                document.body.classList.remove('replay-locked');
            }
        }

        /**
         * Update lockout banner day counter.
         */
        function updateReplayLockoutDay(day, totalDays) {
            const banner = document.getElementById('replay-lockout-banner');
            if (banner && replayState.active) {
                banner.textContent = `SIMULATION         — D          / ${totalDays}`;
            }
        }

        /**
             ow/hide replay mode indicator.
         * Displays "REPLAY MODE — TIME COMPRESSION ×N" when kinematic replay is active.
         */
        function setReplayModeIndicator(enabled, timeScale = 1) {
            const indicator = document.getElementById('replay-mode-indicator');
            if (!indicator) return;

            if (enabled) {
                indicator.textContent = `REPLAY MODE — TIME COMPRESSION ×${Math.round(timeScale)}`;
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        /**
         * Commit scenario results to the ledger (irreversible).
         * Stores full metrics for two-tier table rendering.
         */
        function commitToLedger(scenarioName) {
            if (!replayState.active) return;

            const { summary, baseline } = replayState;
            const isBaseline = scenarioName === 'Baseline';

            // Get display name from narrative order
            const narrativeEntry = SCENARIO_NARRATIVE_ORDER.find(o =>
                o.key === scenarioName ||
                SCENARIO_NAME_MAP[scenarioName] === o.key
            );
            const displayName = narrativeEntry ? narrativeEntry.display : scenarioName;

            // Store all metrics needed for persistent comparison table (per-truck, not absolute)
            ledgerRows.push({
                scenarioName,
                displayName,
                isBaseline,
                // Primary: Per-truck delay metrics (h/camión)
                avgDelayPerTruck: summary.avgDelayPerTruck ?? 0,
                avgCongestionPerTruck: summary.avgCongestionPerTruck ?? 0,
                avgBridgeQueuePerTruck: summary.avgBridgeQueuePerTruck ?? 0,
                avgLotWaitPerTruck: summary.avgLotWaitPerTruck ?? 0,
                // Structural context (non-ranked)
                injectionTons: summary.injectedKg_final ? Math.round(summary.injectedKg_final / 1000) : null,
                cbpLanesMean: summary.cbpLanesInUse_mean,
                lotCapacityMt: summary.totalLotCapacityKg ? summary.totalLotCapacityKg / 1e6 : null,
                // Baseline reference for deltas (per-truck)
                baselineRef: isBaseline ? null : {
                    avgDelayPerTruck: baseline?.avgDelayPerTruck,
                    avgCongestionPerTruck: baseline?.avgCongestionPerTruck,
                    avgBridgeQueuePerTruck: baseline?.avgBridgeQueuePerTruck,
                    avgLotWaitPerTruck: baseline?.avgLotWaitPerTruck,
                },
            });

            // Update ledger display
            renderLedger();

            // End replay
            replayState.active = false;
            console.log(`[Replay] Committed to ledger: ${scenarioName}`);
        }

        /**
         * Render the cumulative ledger table.
         * ═══════════════════════════════════════════════════════════════
         * PERSISTENT COMPARISON TABLE (B) - Ledger version
         * Role: comparative judgment. Normalized per-truck metrics. Deltas allowed.
         * ═══════════════════════════════════════════════════════════════
         */
        function renderLedger() {
            const container = document.getElementById('comparison-table');
            if (!container) return;

            if (ledgerRows.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Helper: format per-truck delta as subtext
            function formatPerTruckDelta(value, baselineValue) {
                if (baselineValue === undefined || baselineValue === null) return '';
                const d = value - baselineValue;
                if (Math.abs(d) < 0.001) return '';
                const sign = d >= 0 ? '+' : '';
                const cls = d < 0 ? 'negative' : 'positive';
                return `<span class="delta ${cls}">${sign}${d.toFixed(2)}</span>`;
            }

            // PRIMARY: Per-truck delay metrics (h/camión)
            const primaryRows = ledgerRows.map(row => {
                const delayDelta = row.baselineRef ? formatPerTruckDelta(row.avgDelayPerTruck, row.baselineRef.avgDelayPerTruck) : '';
                const congestionDelta = row.baselineRef ? formatPerTruckDelta(row.avgCongestionPerTruck, row.baselineRef.avgCongestionPerTruck) : '';
                const cbpQueueDelta = row.baselineRef ? formatPerTruckDelta(row.avgBridgeQueuePerTruck, row.baselineRef.avgBridgeQueuePerTruck) : '';
                const lotWaitDelta = row.baselineRef ? formatPerTruckDelta(row.avgLotWaitPerTruck, row.baselineRef.avgLotWaitPerTruck) : '';

                return `<div class="table-row${row.isBaseline ? ' baseline' : ''}">
                    <span>${row.displayName}</span>
                    <span>${row.avgDelayPerTruck.toFixed(2)}${delayDelta}</span>
                    <span>${row.avgCongestionPerTruck.toFixed(2)}${congestionDelta}</span>
                    <span>${row.avgBridgeQueuePerTruck.toFixed(3)}${cbpQueueDelta}</span>
                    <span>${row.avgLotWaitPerTruck.toFixed(3)}${lotWaitDelta}</span>
                </div>`;
            }).join('');

            // STRUCTURAL CONTEXT: Non-ranked
            const contextRows = ledgerRows.map(row => `
                <div class="table-row${row.isBaseline ? ' baseline' : ''}">
                    <span>${row.displayName}</span>
                    <span>${row.injectionTons !== null ? row.injectionTons : '—'}</span>
                    <span>${row.cbpLanesMean !== undefined ? row.cbpLanesMean.toFixed(1) : '—'}</span>
                    <span>${row.lotCapacityMt !== null ? row.lotCapacityMt.toFixed(1) : '—'}</span>
                </div>
            `).join('');

            container.innerHTML = `
                <div class="tier-label">Demora por camión (h/camión)</div>
                <div class="table-header">
                    <span>Escenario</span>
                    <span>Demora total</span>
                    <span>Congestión</span>
                    <span>Cola CBP</span>
                    <span>Patios</span>
                </div>
                ${primaryRows}

                <div class="tier-label">Contexto estructural</div>
                <div class="table-header">
                    <span>Escenario</span>
                    <span>Inyección (t)</span>
                    <span>CBP prom</span>
                    <span>Cap patios (Mt)</span>
                </div>
                ${contextRows}
            `;
            container.style.display = 'block';
        }

        /**
         * Reset ledger for new comparison run.
         */
        function resetLedger() {
            ledgerRows = [];
            const container = document.getElementById('comparison-table');
            if (container) {
                container.innerHTML = '';
                container.style.display = 'none';
            }
        }

        // =====================================================================
        // ORIENTATION LABELS
        // =====================================================================

        // Load validation data and coordinate files
        let validationData = null;
        let usDestinationCoords = null;
        let mexicanOriginCoords = null;

        async function loadOrientationData() {
            try {
                const [validationRes, usDestRes, mxOrigRes] = await Promise.all([
                    fetch('../mexican_export_validation_results.json').catch(() => null),
                    fetch('../data/us_destinations.json').catch(() => null),
                    fetch('../data/mexican_origins.json').catch(() => null),
                ]);
                if (validationRes?.ok) validationData = await validationRes.json();
                if (usDestRes?.ok) usDestinationCoords = await usDestRes.json();
                if (mxOrigRes?.ok) mexicanOriginCoords = await mxOrigRes.json();
                console.log('[Orientation] Data loaded:', {
                    validation: !!validationData,
                    usCoords: !!usDestinationCoords,
                    mxCoords: !!mexicanOriginCoords,
                    usCitiesAvailable: validationData?.us_destination_analysis?.top_cities ? Object.keys(validationData.us_destination_analysis.top_cities).length : 0,
                    mxCitiesAvailable: validationData?.mexican_origin_analysis?.top_cities ? Object.keys(validationData.mexican_origin_analysis.top_cities).length : 0,
                });

                // Build gravity sink potential field
                if (validationData?.faf_region_city_totals_kg && usDestinationCoords) {
                    pendingPotentialField = buildPotentialField(validationData, usDestinationCoords, latLonToWorld);
                    // Apply to macroParticles if already created
                    if (macroParticles) {
                        macroParticles.setPotentialField(pendingPotentialField);
                    }
                }
            } catch (e) {
                console.warn('[Orientation] Failed to load data:', e);
            }
        }
        let pendingPotentialField = null;  // Holds field until macroParticles is ready
        loadOrientationData();

        // Prepare label data for rendering (with weight for node sizing)
        function prepareSinkLabels(topN = Infinity) {
            if (!validationData?.us_destination_analysis?.top_cities || !usDestinationCoords) {
                console.warn('[Orientation] Cannot prepare sink labels - missing data');
                return [];
            }
            const cities = validationData.us_destination_analysis.top_cities;
            const labels = [];
            // Find max share for normalization (across ALL cities)
            let maxShare = 0;
            for (const [, data] of Object.entries(cities)) {
                if (data.share > maxShare) maxShare = data.share;
            }
            for (const [cityName, data] of Object.entries(cities)) {
                const key = normalizeCityName(cityName);
                const coords = usDestinationCoords[key];
                if (!coords) continue;
                const world = latLonToWorld(coords.lat, coords.lon);
                const weight = maxShare > 0 ? data.share / maxShare : 0.5;
                labels.push({ name: cityName, rank: data.rank, worldX: world.x, worldY: world.y, weight, type: 'sink' });
            }
            labels.sort((a, b) => a.rank - b.rank);
            console.log(`[Orientation] Prepared ${labels.length} US sink nodes (ALL)`);
            return labels;
        }

        function prepareSourceLabels(topN = Infinity) {
            if (!validationData?.mexican_origin_analysis?.top_cities || !mexicanOriginCoords) {
                console.warn('[Orientation] Cannot prepare source labels - missing data');
                return [];
            }
            const cities = validationData.mexican_origin_analysis.top_cities;
            const labels = [];
            // Find max share for normalization (across ALL cities)
            let maxShare = 0;
            for (const [, data] of Object.entries(cities)) {
                if (data.share > maxShare) maxShare = data.share;
            }
            for (const [cityName, data] of Object.entries(cities)) {
                const key = normalizeCityName(cityName);
                const coords = mexicanOriginCoords[key];
                if (!coords) continue;
                const world = latLonToWorld(coords.lat, coords.lon);
                const weight = maxShare > 0 ? data.share / maxShare : 0.5;
                labels.push({ name: cityName, rank: data.rank, worldX: world.x, worldY: world.y, weight, type: 'source' });
            }
            labels.sort((a, b) => a.rank - b.rank);
            console.log(`[Orientation] Prepared ${labels.length} MX source nodes (ALL)`);
            return labels;
        }

        // POE hierarchy labels - exactly two markers
        // Nuevo Laredo - Laredo #1, Reynosa-Pharr #2
        function preparePoeLabels() {
            const POE_DATA = [
                { name: 'Nuevo Laredo - Laredo', rank: 1, lat: 27.47983, lon: -99.62877, flipLeft: true },
                { name: 'Reynosa-Pharr', rank: 2, lat: 26.066, lon: -98.205, flipLeft: false },
            ];
            return POE_DATA.map(poe => {
                const world = latLonToWorld(poe.lat, poe.lon);
                return { name: poe.name, rank: poe.rank, worldX: world.x, worldY: world.y, isPoe: true, flipLeft: poe.flipLeft };
            });
        }

        // Render orientation nodes on canvas
        // - POEs: text labels with leader lines
        // - Sinks (US destinations): lighter grey nodes
        // - Sources (Mexican origins): darker grey nodes
        function renderOrientationLabels(ctx, camera) {
            if (!orientationLabels.visible || orientationLabels.labels.length === 0) return;

            const zoom = camera.zoom || 0.001;
            const cx = camera.centerWorld.x;
            const cy = camera.centerWorld.y;
            const hw = camera.canvasWidth / 2;
            const hh = camera.canvasHeight / 2;

            ctx.save();
            ctx.globalAlpha = orientationLabels.opacity;

            // Node sizing: 4-14px range for better visibility
            const minRadius = 4;
            const maxRadius = 14;

            // Separate labels by type
            const poeLabels = [];
            const sinkNodes = [];
            const sourceNodes = [];

            for (const label of orientationLabels.labels) {
                if (label.isPoe) {
                    poeLabels.push(label);
                } else if (label.type === 'source') {
                    sourceNodes.push(label);
                } else {
                    sinkNodes.push(label);
                }
            }

            // Sources: no rendering (particles speak for themselves)

            // Sink nodes (US destinations) - text labels for top 5 only
            // Gravity effect is via particle Z-displacement
            const top5Sinks = sinkNodes.filter(s => s.rank <= 5);
            // Manual flip overrides: left side = true, right side = false
            const flipOverrides = {
                'San Francisco': true,   // #4 - flip left
                'Dallas': false,         // #1 - right side
                'Houston': false,        // #2 - right side
                'Rio Grande Valley': false  // #5 - right side
            };
            if (top5Sinks.length > 0) {
                ctx.font = '21px "JetBrains Mono", monospace';
                ctx.textBaseline = 'middle';
                const tickLength = 8;
                const tickAngle = Math.PI / 5;
                const leaderLength = 33;

                for (const label of top5Sinks) {
                    const sx = Math.round(hw + (label.worldX - cx) * zoom);
                    const sy = Math.round(hh - (label.worldY - cy) * zoom);
                    if (sx < -100 || sx > camera.canvasWidth + 100 || sy < -100 || sy > camera.canvasHeight + 100) continue;

                    // Use override if exists, else auto-flip based on position
                    const flip = flipOverrides[label.name] ?? (sx > camera.canvasWidth / 2);
                    const actualTickAngle = flip ? Math.PI - tickAngle : tickAngle;
                    const tickEndX = sx + Math.cos(actualTickAngle) * tickLength;
                    const tickEndY = sy - Math.sin(actualTickAngle) * tickLength;
                    const leaderEndX = flip ? tickEndX - leaderLength : tickEndX + leaderLength;

                    // Tick line
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(tickEndX, tickEndY);
                    ctx.stroke();

                    // Leader line
                    ctx.beginPath();
                    ctx.moveTo(tickEndX, tickEndY);
                    ctx.lineTo(leaderEndX, tickEndY);
                    ctx.stroke();

                    // Label text
                    const labelText = `${label.name} — #${label.rank}`;
                    const textMetrics = ctx.measureText(labelText);
                    const textHeight = 21;
                    const padding = 2;
                    const textY = tickEndY;

                    let textX, bgX;
                    if (flip) {
                        textX = leaderEndX - 6 - textMetrics.width;
                        bgX = textX - padding;
                    } else {
                        textX = leaderEndX + 6;
                        bgX = textX - padding;
                    }

                    // Background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fillRect(bgX, textY - textHeight / 2 - padding, textMetrics.width + padding * 2, textHeight + padding * 2);

                    // Text
                    ctx.fillStyle = '#000000';
                    ctx.fillText(labelText, textX, textY);
                }
            }

            // Draw POE text labels with leader lines
            if (poeLabels.length > 0) {
                ctx.font = '22px "JetBrains Mono", monospace';
                ctx.textBaseline = 'middle';
                const tickLength = 30;
                const tickAngle = Math.PI / 6;
                const leaderLength = 120;

                for (const label of poeLabels) {
                    const sx = Math.round(hw + (label.worldX - cx) * zoom);
                    const sy = Math.round(hh - (label.worldY - cy) * zoom);
                    if (sx < -100 || sx > camera.canvasWidth + 100 || sy < -50 || sy > camera.canvasHeight + 50) continue;

                    const flip = label.flipLeft === true;
                    const actualTickAngle = flip ? Math.PI - tickAngle : tickAngle;
                    const tickEndX = sx + Math.cos(actualTickAngle) * tickLength;
                    const tickEndY = sy - Math.sin(actualTickAngle) * tickLength;
                    const leaderEndX = flip ? tickEndX - leaderLength : tickEndX + leaderLength;

                    // Tick line
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(tickEndX, tickEndY);
                    ctx.stroke();

                    // Leader line
                    ctx.beginPath();
                    ctx.moveTo(tickEndX, tickEndY);
                    ctx.lineTo(leaderEndX, tickEndY);
                    ctx.stroke();

                    // Label text
                    const labelText = `${label.name} — #${label.rank}`;
                    const textMetrics = ctx.measureText(labelText);
                    const textHeight = 22;
                    const padding = 4;
                    const textY = tickEndY;

                    let textX, bgX;
                    if (flip) {
                        textX = leaderEndX - 6 - textMetrics.width;
                        bgX = textX - padding;
                    } else {
                        textX = leaderEndX + 6;
                        bgX = textX - padding;
                    }

                    // Background (60% opacity white)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fillRect(bgX, textY - textHeight / 2 - padding, textMetrics.width + padding * 2, textHeight + padding * 2);

                    // Text
                    ctx.fillStyle = '#000000';
                    ctx.fillText(labelText, textX, textY);
                }
            }

            ctx.restore();
        }

        // Lot highlight state
        let lotHighlightActive = false;

        // Framing square state
        let framingSquare = {
            visible: false,
            opacity: 0,
            bounds: null,  // { minX, maxX, minY, maxY } in world coords
        };

        // Interserrana highlight box state
        let interserranaBox = {
            visible: false,
            opacity: 0,
            bounds: {
                minX: -211978.18,
                maxX: -169227.66,
                minY: -160450.94,
                maxY: -72914.16
            }
        };

        // Layer transition indicator (top-left corner square)
        let layerTransitionSquare = {
            visible: false,
            opacity: 0
        };

        // DEV: Comparison mode - shows LAYER_A (green) and baseline (red) simultaneously
        let devComparisonMode = false;
        let devComparisonLayerA = null;  // Second particle layer for α=0

        // Calculate framing square bounds for the target region
        function calculateFramingBounds(target = 'reynosa') {
            // Frame targets
            const FRAME_TARGETS = {
                // Wide frame: NLD, Pharr, Dallas, Houston
                wide: { x: -68197, y: 119285, zoom: 0.001772 },
                // Reynosa local frame
                reynosa: { x: -8491, y: -5982, zoom: 0.044488 },
                // Inovus lot detail
                inovus: { x: -1439, y: -7580, zoom: 0.089946 },
            };
            const t = FRAME_TARGETS[target] || FRAME_TARGETS.reynosa;
            // Calculate bounds based on canvas size at target zoom
            const halfWidth = (camera.canvasWidth / 2) / t.zoom;
            const halfHeight = (camera.canvasHeight / 2) / t.zoom;
            return {
                minX: t.x - halfWidth,
                maxX: t.x + halfWidth,
                minY: t.y - halfHeight,
                maxY: t.y + halfHeight
            };
        }

        // Render framing square
        function renderFramingSquare(ctx, camera) {
            if (!framingSquare.visible || !framingSquare.bounds) return;

            const zoom = camera.zoom || 0.001;
            const cx = camera.centerWorld.x;
            const cy = camera.centerWorld.y;
            const hw = camera.canvasWidth / 2;
            const hh = camera.canvasHeight / 2;
            const b = framingSquare.bounds;

            // Convert bounds to screen
            const x1 = hw + (b.minX - cx) * zoom;
            const y1 = hh - (b.maxY - cy) * zoom;
            const x2 = hw + (b.maxX - cx) * zoom;
            const y2 = hh - (b.minY - cy) * zoom;

            ctx.save();
            ctx.globalAlpha = framingSquare.opacity;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            ctx.restore();
        }

        // Render interserrana highlight box
        function renderInterserranaBox(ctx, camera) {
            if (!interserranaBox.visible) return;

            const zoom = camera.zoom || 0.001;
            const cx = camera.centerWorld.x;
            const cy = camera.centerWorld.y;
            const hw = camera.canvasWidth / 2;
            const hh = camera.canvasHeight / 2;
            const b = interserranaBox.bounds;

            // Convert bounds to screen
            const x1 = hw + (b.minX - cx) * zoom;
            const y1 = hh - (b.maxY - cy) * zoom;
            const x2 = hw + (b.maxX - cx) * zoom;
            const y2 = hh - (b.minY - cy) * zoom;

            ctx.save();
            ctx.globalAlpha = interserranaBox.opacity;
            ctx.strokeStyle = '#ff00ff';  // Magenta to match corridor highlight
            ctx.lineWidth = 1.5;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            ctx.restore();
        }

        // Render layer transition indicator (top-left corner)
        function renderLayerTransitionSquare(ctx, camera) {
            if (!layerTransitionSquare.visible) return;

            const size = 40;
            const margin = 20;
            const x = margin;
            const y = margin;

            ctx.save();
            ctx.globalAlpha = layerTransitionSquare.opacity;
            ctx.fillStyle = '#00ff88';  // Green for "adapted"
            ctx.fillRect(x, y, size, size);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, size, size);
            ctx.restore();
        }

        // Render lot highlight overlay
        // Uses regionMap to ensure ONLY lot cells are drawn (not roads)
        function renderLotHighlight(ctx, camera) {
            if (!lotHighlightActive) return;

            const debug = getPhysicsDebugData();
            if (!debug || !debug.regionMap || !debug.REGION_LOT) return;

            const { N, roi, regionMap, REGION_LOT, fieldToWorldX, fieldToWorldY } = debug;
            const cellPx = Math.max(1, camera.metersToPixels(roi.cellSize));

            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 150, 0.35)';
            ctx.strokeStyle = 'rgba(0, 255, 150, 0.9)';
            ctx.lineWidth = 1;

            // Draw ONLY cells marked as REGION_LOT in the regionMap
            const N2 = N * N;
            for (let idx = 0; idx < N2; idx++) {
                if (regionMap[idx] !== REGION_LOT) continue;

                const fx = idx % N;
                const fy = Math.floor(idx / N);
                const wx = fieldToWorldX(fx + 0.5);
                const wy = fieldToWorldY(fy + 0.5);
                const screen = camera.worldToScreen(wx, wy);

                ctx.fillRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
            }

            // Draw lot outlines (strokes) separately for cleaner edges
            ctx.strokeStyle = 'rgba(0, 255, 150, 0.9)';
            for (let idx = 0; idx < N2; idx++) {
                if (regionMap[idx] !== REGION_LOT) continue;

                const fx = idx % N;
                const fy = Math.floor(idx / N);
                const wx = fieldToWorldX(fx + 0.5);
                const wy = fieldToWorldY(fy + 0.5);
                const screen = camera.worldToScreen(wx, wy);

                ctx.strokeRect(screen.x - cellPx / 2, screen.y - cellPx / 2, cellPx, cellPx);
            }
            ctx.restore();
        }

        // Helper to patch alienObserver script with actual particle mass
        function patchScriptWithParticleMass(script) {
            const tons = (window.MACRO_KG_PER_PARTICLE || 30000) / 1000;
            for (const instr of script) {
                if (instr.type === 'overlay' && instr.text && instr.text.includes('Unidad: Flujo')) {
                    instr.text = `Unidad: Flujo (${tons}t)`;
                }
            }
            return script;
        }

        // Load default script (alien observer - no narration)
        director.load(patchScriptWithParticleMass(Scripts.alienObserver()));

        // Dismiss splash when system is ready AND frame rate is stable AND minimum time elapsed
        // Waits for: macroParticles initialized, bundle loaded, smooth rendering, and 15s hold time
        let splashDismissed = false;
        let stableFrameCount = 0;
        let lastSplashCheckTime = 0;
        const splashStartTime = performance.now();
        const SPLASH_MIN_HOLD_MS = 20000;   // Hold splash for at least 20 seconds
        const STABLE_FRAMES_REQUIRED = 10;  // Need 10 consecutive good frames
        const MIN_FPS_THRESHOLD = 30;       // Frame must be >30fps to count as stable

        function checkSplashDismiss(timestamp) {
            if (splashDismissed) return;

            // Need macroParticles and bundleLoaded
            if (macroParticles === null || !bundleLoaded) {
                stableFrameCount = 0;
                requestAnimationFrame(checkSplashDismiss);
                return;
            }

            // Check minimum hold time
            if (timestamp - splashStartTime < SPLASH_MIN_HOLD_MS) {
                requestAnimationFrame(checkSplashDismiss);
                return;
            }

            // Check frame rate stability
            if (lastSplashCheckTime > 0) {
                const dt = timestamp - lastSplashCheckTime;
                const fps = 1000 / dt;
                if (fps >= MIN_FPS_THRESHOLD) {
                    stableFrameCount++;
                } else {
                    stableFrameCount = 0;  // Reset on bad frame
                }
            }
            lastSplashCheckTime = timestamp;

            // Dismiss after enough stable frames
            if (stableFrameCount >= STABLE_FRAMES_REQUIRED) {
                splashDismissed = true;
                // Immediate fade (user already waited through loading)
                const splash = document.getElementById('splash-screen');
                if (splash) {
                    splash.classList.add('fade-out');
                    setTimeout(() => splash.remove(), 2000);
                }
            } else {
                requestAnimationFrame(checkSplashDismiss);
            }
        }
        requestAnimationFrame(checkSplashDismiss);

        function resize() {
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            glCanvas.width = canvas.width;
            glCanvas.height = canvas.height;
            if (glRenderer.isAvailable()) {
                glRenderer.resize(canvas.width, canvas.height);
            }
            camera.canvasWidth = canvas.width;
            camera.canvasHeight = canvas.height;
            // Re-fit current semantic frame (preserves world-space framing on resize)
            camera.refitCurrentFrame();
        }
        window.addEventListener('resize', resize);

        // =====================================================================
        // CONTROLS
        // =====================================================================

        const hourSlider = document.getElementById('hour-slider');
        const hourValue = document.getElementById('hour-value');
        const zoomSlider = document.getElementById('zoom-slider');

        hourSlider.addEventListener('input', () => {
            time.setHour(parseInt(hourSlider.value));
            hourValue.textContent = hourSlider.value.padStart(2, '0') + ':00';
        });

        // Display authoritative time scale (no longer editable)
        document.getElementById('timescale-value').textContent =
            `${ReynosaEastOverlay.SIM_TIME_SCALE.toFixed(0)} sim-s/real-s`;

        document.getElementById('btn-pause').addEventListener('click', () => {
            time.togglePause();
            document.getElementById('btn-pause').textContent = time.paused ? 'Resume' : 'Pause';
            // Show/hide replay controls
            document.getElementById('replay-controls').style.display = time.paused ? 'block' : 'none';
            if (time.paused) updateReplayUI();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            time.simTimeSeconds = 8 * 3600;
            if (fieldAttached) {
                ReynosaEastOverlay.onDetach();
                fieldAttached = false;
                fieldInitialized = false;
            }
            if (currentZoomState === ZoomState.LOCAL_FIELD) {
                initFieldFromCien();
            }
        });

        document.getElementById('btn-macro').addEventListener('click', () => {
            camera.focusMacro();
            updateZoomSlider();
        });

        document.getElementById('btn-local').addEventListener('click', () => {
            camera.focusLocal();
            updateZoomSlider();
        });

        // =====================================================================
        // INSTANT REPLAY CONTROLS
        // =====================================================================
        function formatSimTime(seconds) {
            const h = Math.floor(seconds / 3600) % 24;
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateReplayUI() {
            const currentTime = getSimTime();
            document.getElementById('replay-time').textContent = formatSimTime(currentTime);
            const count = getSnapshotCount();
            const oldest = getOldestSnapshotTime();
            const range = oldest !== null ? Math.floor(currentTime - oldest) : 0;
            document.getElementById('replay-info').textContent = `Buffer: ${count} snapshots (${range}s)`;
        }

        document.getElementById('btn-back-5s').addEventListener('click', () => {
            const targetTime = getSimTime() - 5;
            if (restoreSnapshot(targetTime)) {
                time.simTimeSeconds = getSimTime();  // Sync external time object
                updateReplayUI();
                console.log(`[REPLAY] Restored to ${formatSimTime(getSimTime())}`);
            } else {
                console.log('[REPLAY] No snapshot available for that time');
            }
        });

        document.getElementById('btn-step-1s').addEventListener('click', () => {
            captureSnapshot();  // Save current state before stepping
            step(1.0);  // Advance 1 sim-second
            time.simTimeSeconds = getSimTime();  // Sync external time object
            updateReplayUI();
            console.log(`[REPLAY] Stepped to ${formatSimTime(getSimTime())}`);
        });

        // Helper to clear dimension stack
        function clearDimStack() {
            for (let i = 1; i <= 3; i++) {
                const el = document.getElementById(`dim-${i}`);
                if (el) {
                    el.classList.remove('visible', 'faded');
                    el.textContent = '';
                }
            }
            const desc = document.getElementById('dim-1-desc');
            if (desc) {
                desc.classList.remove('visible');
                desc.innerHTML = '';
            }
        }

        // Skip to Local Sim - overrides director, jumps straight to local sim
        document.getElementById('btn-skip-to-local').addEventListener('click', () => {
            // Stop director
            director.stop();

            // Hide intro text
            introTextEl.style.display = 'none';
            introTextEl.style.opacity = '0';

            // Hide dimension stack
            clearDimStack();

            // Unpause macro particles
            if (macroParticles) {
                macroParticles.paused = false;
            }

            // Focus on local view
            camera.focusLocal();
            updateZoomSlider();

            // Unpause local sim
            time.paused = false;
            document.getElementById('btn-pause').textContent = 'Pause';

            // Enable free camera (pan/zoom) and spacebar pause
            freeCamera = true;

            console.log('[Skip] Jumped to local sim, free camera enabled');
        });

        // Clear debug cache button
        document.getElementById('btn-clear-debug-cache').addEventListener('click', clearDebugCache);

        // Interserrana toggle button (sidebar)
        const btnInterserrana = document.getElementById('btn-interserrana');
        // Handler added after sync functions are defined

        // Twin Span toggle button (sidebar)
        const btnTwinSpan = document.getElementById('btn-twin-span');
        // Handler added after sync functions are defined

        // INOVUS toggle button (sidebar)
        const btnInovus = document.getElementById('btn-inovus');
        // Handler added after sync functions are defined

        // Bundle variant toggle button (sidebar)
        const btnBundleVariant = document.getElementById('btn-bundle-variant');
        // Handler added after sync functions are defined

        // =====================================================================
        // BOTTOM ACTION BAR - Wired to same toggle functions, synced state
        // =====================================================================

        const btnBarInterserrana = document.getElementById('btn-bar-interserrana');
        const btnBarInovus = document.getElementById('btn-bar-inovus');
        const btnBarTwinspan = document.getElementById('btn-bar-twinspan');
        const btnBarBundleVariant = document.getElementById('btn-bar-bundle-variant');

        // Sync helper: updates both sidebar and bottom bar buttons
        function syncInterserranaButtons(isActive) {
            btnInterserrana.classList.toggle('active', isActive);
            btnInterserrana.textContent = isActive ? '← Baseline' : 'Interserrana →';
            btnBarInterserrana.classList.toggle('active', isActive);
            btnBarInterserrana.textContent = isActive ? '← Baseline' : 'Interserrana';
        }

        function syncInovusButtons(isActive) {
            btnInovus.classList.toggle('active', isActive);
            btnInovus.textContent = isActive ? '← INOVUS OFF' : 'INOVUS →';
            btnBarInovus.classList.toggle('active', isActive);
            btnBarInovus.textContent = isActive ? '← OFF' : 'INOVUS';
        }

        function syncTwinspanButtons(isActive) {
            btnTwinSpan.classList.toggle('active', isActive);
            btnTwinSpan.textContent = isActive ? '← Single Span' : 'Twin Span →';
            btnBarTwinspan.classList.toggle('active', isActive);
            btnBarTwinspan.textContent = isActive ? '← Single' : 'Twin Span';
        }

        function syncBundleVariantButtons(suffix) {
            const VARIANT_NAMES = { '': 'Default', '_blockedsegments': 'Blocked', '_LAYER_A': 'LAYER_A' };
            const currentIdx = BUNDLE_VARIANTS.indexOf(suffix);
            const nextIdx = (currentIdx + 1) % BUNDLE_VARIANTS.length;
            const nextName = VARIANT_NAMES[BUNDLE_VARIANTS[nextIdx]];
            const currentName = VARIANT_NAMES[suffix];
            const isActive = suffix !== '';
            btnBundleVariant.classList.toggle('active', isActive);
            btnBundleVariant.textContent = `${currentName} → ${nextName}`;
            btnBarBundleVariant.classList.toggle('active', isActive);
            btnBarBundleVariant.textContent = `${currentName} → ${nextName}`;
        }

        // Bottom bar: Interserrana
        btnBarInterserrana.addEventListener('click', () => {
            if (!interserranaBundleLoaded) return;
            macroTargetAlpha = macroTargetAlpha === 0 ? 1 : 0;
            macroRampStartTime = performance.now();
            macroRampStartAlpha = macroAlpha;
            syncInterserranaButtons(macroTargetAlpha === 1);
            console.log('[Scenario] Target α:', macroTargetAlpha);
        });

        // Bottom bar: INOVUS
        btnBarInovus.addEventListener('click', async () => {
            await ReynosaEastOverlay.togglePhasesAsLots();
            const isActive = ReynosaEastOverlay.isPhasesAsLots();
            syncInovusButtons(isActive);
        });

        // Bottom bar: Twin Span
        btnBarTwinspan.addEventListener('click', () => {
            twinSpanTargetAlpha = twinSpanTargetAlpha === 0 ? 1 : 0;
            twinSpanRampStartTime = performance.now();
            twinSpanRampStartAlpha = twinSpanAlpha;
            syncTwinspanButtons(twinSpanTargetAlpha === 1);
            console.log('[Twin Span] Target α:', twinSpanTargetAlpha);
        });

        // Bottom bar: Bundle Variant
        btnBarBundleVariant.addEventListener('click', async () => {
            await toggleBundleVariant();
            syncBundleVariantButtons(currentBundleSuffix);
        });

        // Bottom bar: Stress Test (5x particles, 5x weight each)
        const btnBarStressTest = document.getElementById('btn-bar-stress-test');
        btnBarStressTest.addEventListener('click', () => {
            const wasActive = isStressMode();
            setStressMode(!wasActive);
            const nowActive = isStressMode();
            btnBarStressTest.classList.toggle('active', nowActive);
            btnBarStressTest.textContent = nowActive ? 'Stress 5x ON' : 'Stress 5x';
            console.log('[Stress Test]', nowActive ? 'ENABLED (5x particles, 5x weight)' : 'DISABLED');
        });

        // Sidebar handlers (use sync functions)
        btnInterserrana.addEventListener('click', () => {
            if (!interserranaBundleLoaded) return;
            macroTargetAlpha = macroTargetAlpha === 0 ? 1 : 0;
            macroRampStartTime = performance.now();
            macroRampStartAlpha = macroAlpha;
            syncInterserranaButtons(macroTargetAlpha === 1);
            console.log('[Scenario] Target α:', macroTargetAlpha);
        });

        btnTwinSpan.addEventListener('click', () => {
            twinSpanTargetAlpha = twinSpanTargetAlpha === 0 ? 1 : 0;
            twinSpanRampStartTime = performance.now();
            twinSpanRampStartAlpha = twinSpanAlpha;
            syncTwinspanButtons(twinSpanTargetAlpha === 1);
            console.log('[Twin Span] Target α:', twinSpanTargetAlpha);
        });

        btnInovus.addEventListener('click', async () => {
            await ReynosaEastOverlay.togglePhasesAsLots();
            const isActive = ReynosaEastOverlay.isPhasesAsLots();
            syncInovusButtons(isActive);
        });

        btnBundleVariant.addEventListener('click', async () => {
            await toggleBundleVariant();
            syncBundleVariantButtons(currentBundleSuffix);
        });

        // Headless A/B comparison test button
        const btnHeadlessTest = document.getElementById('btn-headless-test');
        const headlessStatus = document.getElementById('headless-status');

        // Config
        const DAYS = 7;
        const HOUR = 3600;
        const TEST_DURATION = DAYS * 24 * HOUR;  // 7 days
        const WARMUP = 6 * HOUR;  // 6 hour warmup for mean calculation
        const SAMPLE_INTERVAL = 300;  // 5 minutes
        const DT = 1.0;
        const CHUNK_SIZE = 3600;  // 1 hour per chunk (prevents browser freeze)
        const TRUCK_KG = 9000;
        const MASS_TOL = 10000;

        // Run single scenario (async, chunked)
        async function runScenario(name, applyScenario) {
            headlessStatus.textContent = `${name}: Applying scenario...`;
            await applyScenario();
            reset();
            setSimTime(0);

            const startMetrics = getMetricsPhase1();
            const samples = [];
            const violations = [];
            let prev = null;
            let simTime = 0;
            let nextSample = 0;

            while (simTime < TEST_DURATION) {
                // Run chunk
                const chunkEnd = Math.min(simTime + CHUNK_SIZE, TEST_DURATION);
                while (simTime < chunkEnd) {
                    setSimTime(simTime);
                    step(DT);
                    simTime += DT;

                    if (simTime >= nextSample) {
                        const raw = getMetricsPhase1();

                        // Mass invariant on RAW
                        const massError = Math.abs(
                            (raw.injectedKg - raw.exitedKg) - (raw.activeParticles * TRUCK_KG)
                        );
                        if (massError > MASS_TOL) {
                            violations.push({ type: 'mass', t: simTime, error: massError });
                        }

                        // Rate bound invariant: rate <= activeParticles + 1
                        if (raw.truckHoursLostRate > raw.activeParticles + 1) {
                            violations.push({
                                type: 'rateBound',
                                t: simTime,
                                rate: raw.truckHoursLostRate,
                                particles: raw.activeParticles
                            });
                        }

                        // Delta accounting for reporting
                        const m = {
                            t: simTime,
                            injectedKg: raw.injectedKg - startMetrics.injectedKg,
                            exitedKg: raw.exitedKg - startMetrics.exitedKg,
                            activeParticles: raw.activeParticles,
                            truckHoursLost: raw.truckHoursLost - startMetrics.truckHoursLost,
                            truckHoursLostRate: raw.truckHoursLostRate,
                            stallTonHours: raw.stallTonHours - startMetrics.stallTonHours,
                        };

                        // Monotonicity
                        if (prev && m.truckHoursLost < prev.truckHoursLost - 1e-6) {
                            violations.push({ type: 'monotonicLoss', t: simTime });
                        }

                        samples.push(m);
                        prev = m;
                        nextSample += SAMPLE_INTERVAL;
                    }
                }

                // Update progress
                const pct = Math.floor((simTime / TEST_DURATION) * 100);
                const days = (simTime / 86400).toFixed(1);
                headlessStatus.textContent = `${name}: ${pct}% (${days}d)`;

                // Yield to browser
                await new Promise(r => setTimeout(r, 0));
            }

            const final = samples.at(-1);
            const hours = TEST_DURATION / 3600;

            // Post-warmup samples for mean calculation
            const postWarmup = samples.filter(s => s.t >= WARMUP);
            const rateSum = postWarmup.reduce((acc, s) => acc + s.truckHoursLostRate, 0);
            const rateMean = postWarmup.length > 0 ? rateSum / postWarmup.length : 0;
            const postWarmupHours = (TEST_DURATION - WARMUP) / 3600;

            return {
                name,
                config: { duration: TEST_DURATION, warmup: WARMUP, dt: DT, sampleInterval: SAMPLE_INTERVAL },
                final,
                summary: {
                    truckHoursLost_final: final.truckHoursLost,
                    truckHoursLostRate_mean: rateMean,
                    throughputKgPerHour: final.exitedKg / postWarmupHours,
                },
                samples: samples.slice(-10),  // Last 10 for output
                violations,
                passed: violations.length === 0,
            };
        }

        // Download JSON helper
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        btnHeadlessTest.addEventListener('click', async () => {
            btnHeadlessTest.disabled = true;
            headlessStatus.textContent = 'Starting A/B comparison...';
            headlessStatus.style.color = '#ff0';

            // Pause main animation
            const wasPaused = time.paused;
            if (!wasPaused) time.togglePause();

            try {
                // Run baseline (Inovus OFF)
                const baseline = await runScenario('Baseline', async () => {
                    if (ReynosaEastOverlay.isPhasesAsLots()) {
                        await ReynosaEastOverlay.togglePhasesAsLots();
                    }
                    setTwinSpanCapacityMultiplier(1.0);
                });

                // Run treatment (Inovus ON)
                const treatment = await runScenario('Inovus', async () => {
                    if (!ReynosaEastOverlay.isPhasesAsLots()) {
                        await ReynosaEastOverlay.togglePhasesAsLots();
                    }
                    setTwinSpanCapacityMultiplier(1.0);
                });

                // Compute delta
                const deltaRate = treatment.summary.truckHoursLostRate_mean - baseline.summary.truckHoursLostRate_mean;
                const pctChange = baseline.summary.truckHoursLostRate_mean !== 0
                    ? (deltaRate / baseline.summary.truckHoursLostRate_mean) * 100
                    : 0;

                const headline = deltaRate < 0
                    ? `Congestion reduced by ${Math.abs(pctChange).toFixed(1)}% (rate)`
                    : deltaRate > 0
                        ? `Congestion increased by ${pctChange.toFixed(1)}% (rate)`
                        : 'No change in congestion rate';

                const result = {
                    meta: {
                        timestamp: new Date().toISOString(),
                        scenarios: {
                            baseline: 'Inovus OFF, TwinSpan 1.0',
                            treatment: 'Inovus ON, TwinSpan 1.0',
                        },
                        duration: `${DAYS} days`,
                    },
                    baseline,
                    treatment,
                    delta: {
                        truckHoursLost: treatment.final.truckHoursLost - baseline.final.truckHoursLost,
                        truckHoursLostRate_mean: deltaRate,
                        throughputKg: treatment.final.exitedKg - baseline.final.exitedKg,
                    },
                    headline,
                };

                // Log and download
                console.log('[A/B COMPARISON] Result:', result);
                downloadJSON(result, `baseline_vs_inovus_${DAYS}d.json`);

                // Update status
                const totalViolations = baseline.violations.length + treatment.violations.length;
                if (totalViolations === 0) {
                    headlessStatus.innerHTML = `DONE — ${headline}<br><small>JSON downloaded</small>`;
                    headlessStatus.style.color = '#0f0';
                } else {
                    headlessStatus.innerHTML = `DONE — ${totalViolations} violations<br><small>JSON downloaded</small>`;
                    headlessStatus.style.color = '#f66';
                }

            } catch (err) {
                console.error('[A/B COMPARISON] Failed:', err);
                headlessStatus.textContent = `ERROR: ${err.message}`;
                headlessStatus.style.color = '#f66';
            }

            btnHeadlessTest.disabled = false;
            if (!wasPaused) time.togglePause();
        });

        // Director controls
        document.getElementById('btn-director-play').addEventListener('click', () => {
            if (director.isPlaying()) {
                director.pause();
            } else {
                director.play();
            }
        });

        document.getElementById('btn-director-stop').addEventListener('click', () => {
            director.stop();
            updateZoomSlider();
        });

        document.getElementById('btn-skip').addEventListener('click', () => {
            director.skip();
        });

        // Text now handled by director.narrativeIntro() script
        const introTextEl = document.getElementById('intro-text');
        const btnAvanzar = document.getElementById('btn-avanzar');

        // Auto-play director narrative after fade-in
        setTimeout(() => {
            director.play();
        }, 5500);  // After 5s fade-in + 0.5s buffer

        // Avanzar button hidden - director handles narrative
        btnAvanzar.style.display = 'none';

        document.getElementById('director-script').addEventListener('change', async (e) => {
            const scriptName = e.target.value;
            switch (scriptName) {
                case 'alienObserver':
                    // LAYER_A → baseline already loaded in loadBundleFromFile()
                    director.load(patchScriptWithParticleMass(Scripts.alienObserver()));
                    break;
                case 'alienObserverWithScenarios':
                    // LAYER_A → baseline already loaded, just need metrics
                    await loadScenarioMetrics();
                    director.load(patchScriptWithParticleMass(Scripts.alienObserverWithScenarios()));
                    break;
                case 'narrativeIntro':
                    director.load(Scripts.narrativeIntro());
                    break;
                case 'intro':
                    director.load(Scripts.intro());
                    break;
                case 'corridorTour':
                    director.load(Scripts.corridorTour());
                    break;
                case 'zoomCycle':
                    director.load(Scripts.zoomCycle());
                    break;
            }
            // Sync timeline with newly loaded script
            timeline = JSON.parse(JSON.stringify(director.script));
            renderTimeline();
            directorStatus.textContent = 'Ready';
            directorStatus.style.color = '#666';
        });

        // ═══════════════════════════════════════════════════════════════
        // DIRECTOR PANEL (E key) - TIMELINE SYSTEM
        // ═══════════════════════════════════════════════════════════════

        const directorPanel = document.getElementById('director-panel');
        const dpCamera = document.getElementById('dp-camera');
        const dpTextPos = document.getElementById('dp-text-pos');
        const stepStackEl = document.getElementById('step-stack');
        const dpStepCount = document.getElementById('dp-step-count');
        let directorPanelActive = false;
        let textDragEnabled = false;
        let textDragOffset = { x: 0, y: 0 };
        let freeCamera = false;  // Unlocks camera pan/zoom and spacebar pause

        // Timeline state
        let timeline = [];
        let currentStepIndex = -1;
        let isPlaying = false;

        function toggleDirectorPanel() {
            directorPanelActive = !directorPanelActive;
            directorPanel.classList.toggle('active', directorPanelActive);
            if (directorPanelActive) {
                introTextEl.style.display = 'block';
                introTextEl.innerHTML = introTextEl.innerHTML || 'Sample text for positioning';
                // Sync timeline with currently loaded director script
                if (director.script && director.script.length > 0 && timeline.length === 0) {
                    timeline = JSON.parse(JSON.stringify(director.script));  // Deep copy
                }
                renderTimeline();
            }
            console.log(`[Director] Panel ${directorPanelActive ? 'ON' : 'OFF'}`);
        }

        function updateDirectorPanel() {
            if (!directorPanelActive) return;
            dpCamera.textContent = `x:${Math.round(camera.centerWorld.x)} y:${Math.round(camera.centerWorld.y)} z:${camera.zoom.toFixed(6)}`;
            const rect = introTextEl.getBoundingClientRect();
            const topPct = ((rect.top / window.innerHeight) * 100).toFixed(1);
            const leftPct = ((rect.left / window.innerWidth) * 100).toFixed(1);
            dpTextPos.textContent = `top:${topPct}% left:${leftPct}%`;
        }

        // Step description helper
        function getStepDescription(step) {
            switch (step.type) {
                case 'flyTo': return `→ x:${step.x} y:${step.y} z:${step.zoom?.toFixed(4) || '?'}`;
                case 'text': return step.text?.substring(0, 30) + (step.text?.length > 30 ? '...' : '');
                case 'fadeText': return 'Fade out text';
                case 'action': return step.action || 'Custom action';
                case 'wait': return `${step.duration || 1000}ms`;
                default: return JSON.stringify(step).substring(0, 30);
            }
        }

        // Render timeline UI
        function renderTimeline() {
            stepStackEl.innerHTML = '';
            dpStepCount.textContent = `${timeline.length} steps`;

            timeline.forEach((step, idx) => {
                const item = document.createElement('div');
                item.className = 'step-item' + (idx === currentStepIndex ? ' current' : '');
                item.draggable = true;
                item.dataset.idx = idx;

                item.innerHTML = `
                    <span class="step-num">[${idx + 1}]</span>
                    <span class="step-type">${step.type}</span>
                    <span class="step-desc">${getStepDescription(step)}</span>
                    <div class="step-actions">
                        <button class="step-btn" data-action="up" title="Move up">↑</button>
                        <button class="step-btn" data-action="down" title="Move down">↓</button>
                        <button class="step-btn play" data-action="jump" title="Jump to">▶</button>
                        <button class="step-btn delete" data-action="delete" title="Delete">×</button>
                    </div>
                `;

                // Move up
                item.querySelector('[data-action="up"]').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (idx > 0) {
                        [timeline[idx - 1], timeline[idx]] = [timeline[idx], timeline[idx - 1]];
                        renderTimeline();
                    }
                });

                // Move down
                item.querySelector('[data-action="down"]').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (idx < timeline.length - 1) {
                        [timeline[idx], timeline[idx + 1]] = [timeline[idx + 1], timeline[idx]];
                        renderTimeline();
                    }
                });

                // Jump to step
                item.querySelector('[data-action="jump"]').addEventListener('click', (e) => {
                    e.stopPropagation();
                    jumpToStep(idx);
                });

                // Delete step
                item.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
                    e.stopPropagation();
                    timeline.splice(idx, 1);
                    if (currentStepIndex >= idx) currentStepIndex = Math.max(-1, currentStepIndex - 1);
                    renderTimeline();
                });

                // Click on step-desc to edit text steps
                if (step.type === 'text') {
                    const descEl = item.querySelector('.step-desc');
                    descEl.style.cursor = 'pointer';
                    descEl.title = 'Click to edit';
                    descEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Show text in intro-text and make editable
                        introTextEl.innerHTML = step.text;
                        introTextEl.style.display = 'block';
                        introTextEl.style.opacity = '1';
                        introTextEl.contentEditable = 'true';
                        introTextEl.style.outline = '2px solid #4f4';
                        introTextEl.focus();

                        // Mark which step we're editing
                        introTextEl.dataset.editingIdx = idx;

                        console.log(`[Editor] Editing text step ${idx + 1}`);
                    });
                }

                // Drag events
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', idx);
                    item.classList.add('dragging');
                });
                item.addEventListener('dragend', () => item.classList.remove('dragging'));
                item.addEventListener('dragover', (e) => e.preventDefault());
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIdx = idx;
                    if (fromIdx !== toIdx) {
                        const [moved] = timeline.splice(fromIdx, 1);
                        timeline.splice(toIdx, 0, moved);
                        renderTimeline();
                    }
                });

                stepStackEl.appendChild(item);
            });
        }

        // Handle blur on intro-text to save edits
        document.getElementById('intro-text').addEventListener('blur', function () {
            if (this.contentEditable === 'true') {
                const idx = parseInt(this.dataset.editingIdx);
                if (!isNaN(idx) && timeline[idx] && timeline[idx].type === 'text') {
                    timeline[idx].text = this.innerHTML;
                    console.log(`[Editor] Saved text step ${idx + 1}`);
                    renderTimeline();
                }
                this.contentEditable = 'false';
                this.style.outline = '';
                delete this.dataset.editingIdx;
            }
        });

        // Execute a single step
        async function executeStep(step) {
            switch (step.type) {
                case 'flyTo':
                    return new Promise(resolve => {
                        director.load([{ type: 'flyTo', x: step.x, y: step.y, zoom: step.zoom, duration: step.duration || 2000 }]);
                        director.play();
                        setTimeout(resolve, step.duration || 2000);
                    });
                case 'text':
                    introTextEl.innerHTML = step.text;
                    introTextEl.style.display = 'block';
                    introTextEl.style.opacity = '1';
                    return Promise.resolve();
                case 'fadeText':
                    introTextEl.style.display = 'none';
                    return Promise.resolve();
                case 'action':
                    if (step.action === 'pharrHighlight' && macroParticles) {
                        macroParticles.togglePharrHighlight();
                    }
                    if (step.action === 'turnOffParticles' && macroParticles) {
                        macroParticles.particlesVisible = !macroParticles.particlesVisible;
                        console.log(`[Action] Particles visible: ${macroParticles.particlesVisible}`);
                    }
                    if (step.action === 'flickerSegments' && macroParticles) {
                        macroParticles.toggleDebugTracers();
                    }
                    if (step.action === 'loadLocalSim') {
                        return loadLocalSim();
                    }
                    if (step.action === 'startSim') {
                        time.paused = false;
                        document.getElementById('btn-pause').textContent = 'Pause';
                        console.log('[Action] Simulation STARTED');
                    }
                    if (step.action === 'pauseSim') {
                        time.paused = true;
                        document.getElementById('btn-pause').textContent = 'Resume';
                        console.log('[Action] Simulation PAUSED');
                    }
                    if (step.action === 'enableInterserrana') {
                        if (interserranaBundleLoaded && macroTargetAlpha !== 1) {
                            macroTargetAlpha = 1;
                            macroRampStartTime = performance.now();
                            macroRampStartAlpha = macroAlpha;
                            document.getElementById('btn-interserrana').classList.add('active');
                            document.getElementById('btn-interserrana').textContent = '← Baseline';
                            console.log('[Action] Interserrana ENABLED');
                        }
                    }
                    if (step.action === 'enableTwinSpan') {
                        if (twinSpanTargetAlpha !== 1) {
                            twinSpanTargetAlpha = 1;
                            twinSpanRampStartTime = performance.now();
                            twinSpanRampStartAlpha = twinSpanAlpha;
                            document.getElementById('btn-twin-span').classList.add('active');
                            document.getElementById('btn-twin-span').textContent = '← Single Span';
                            console.log('[Action] Twin Span (Pharr X2) ENABLED');
                        }
                    }
                    if (step.action === 'enableInovus') {
                        if (!ReynosaEastOverlay.isPhasesAsLots()) {
                            await ReynosaEastOverlay.togglePhasesAsLots();
                            document.getElementById('btn-inovus').classList.add('active');
                            document.getElementById('btn-inovus').textContent = '← INOVUS OFF';
                            console.log('[Action] INOVUS ENABLED');
                        }
                    }
                    return Promise.resolve();
                case 'wait':
                    return new Promise(r => setTimeout(r, step.duration || 1000));
                default:
                    return Promise.resolve();
            }
        }

        // Jump to step (execute it immediately)
        async function jumpToStep(idx) {
            if (idx < 0 || idx >= timeline.length) return;
            currentStepIndex = idx;
            renderTimeline();
            await executeStep(timeline[idx]);
            console.log(`[Director] Jumped to step ${idx + 1}: ${timeline[idx].type}`);
        }

        // Play all steps sequentially
        async function playAll() {
            if (isPlaying) return;
            isPlaying = true;
            document.getElementById('dp-play-all').textContent = '⏸ Playing...';

            for (let i = 0; i < timeline.length; i++) {
                currentStepIndex = i;
                renderTimeline();
                await executeStep(timeline[i]);
                await new Promise(r => setTimeout(r, 300)); // Brief pause between steps
            }

            isPlaying = false;
            document.getElementById('dp-play-all').textContent = '▶ Play All';
            console.log('[Director] Playback complete');
        }

        // Add step handlers
        document.getElementById('add-flyto').addEventListener('click', () => {
            timeline.push({
                type: 'flyTo',
                x: Math.round(camera.centerWorld.x),
                y: Math.round(camera.centerWorld.y),
                zoom: parseFloat(camera.zoom.toFixed(6)),
                duration: 2000
            });
            renderTimeline();
            console.log('[Director] Added FlyTo step');
        });

        document.getElementById('add-text').addEventListener('click', () => {
            const text = prompt('Enter text (HTML allowed):', introTextEl.innerHTML || 'Sample text');
            if (text) {
                timeline.push({ type: 'text', text });
                renderTimeline();
                console.log('[Director] Added Text step');
            }
        });

        document.getElementById('add-fadetext').addEventListener('click', () => {
            timeline.push({ type: 'fadeText' });
            renderTimeline();
            console.log('[Director] Added Fade step');
        });

        document.getElementById('add-action').addEventListener('click', (e) => {
            const actions = ['pharrHighlight', 'turnOffParticles', 'flickerSegments', 'loadLocalSim', 'startSim', 'pauseSim', 'enableInterserrana', 'enableTwinSpan', 'enableInovus'];

            // Create dropdown menu
            const menu = document.createElement('div');
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: #333;
                border: 1px solid #555;
                border-radius: 4px;
                z-index: 10000;
                min-width: 160px;
            `;

            actions.forEach(action => {
                const item = document.createElement('div');
                item.textContent = action;
                item.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    color: #fff;
                    font-size: 13px;
                `;
                item.onmouseenter = () => item.style.background = '#555';
                item.onmouseleave = () => item.style.background = 'transparent';
                item.onclick = () => {
                    timeline.push({ type: 'action', action });
                    renderTimeline();
                    console.log(`[Director] Added Action: ${action}`);
                    document.body.removeChild(menu);
                };
                menu.appendChild(item);
            });

            document.body.appendChild(menu);

            // Close on click outside
            const closeMenu = (evt) => {
                if (!menu.contains(evt.target)) {
                    document.body.removeChild(menu);
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        });

        document.getElementById('add-wait').addEventListener('click', () => {
            const ms = prompt('Wait duration (ms):', '1000');
            if (ms) {
                timeline.push({ type: 'wait', duration: parseInt(ms) });
                renderTimeline();
                console.log('[Director] Added Wait step');
            }
        });

        // Control buttons
        document.getElementById('dp-play-all').addEventListener('click', playAll);

        document.getElementById('dp-export-timeline').addEventListener('click', () => {
            const json = JSON.stringify(timeline, null, 4);
            // Format as JS function for director.js
            const jsExport = `    // Exported from editor ${new Date().toISOString().slice(0, 10)}
    customScript() {
        return ${json.split('\n').map((line, i) => i === 0 ? line : '        ' + line).join('\n')};
    },`;
            navigator.clipboard.writeText(jsExport);
            console.log('[Director] Timeline exported as JS:\n' + jsExport);
            alert('Copied to clipboard! Paste into Scripts object in director.js');
        });

        document.getElementById('dp-clear-timeline').addEventListener('click', () => {
            timeline = [];
            currentStepIndex = -1;
            renderTimeline();
            console.log('[Director] Timeline cleared');
        });

        // Toggle Text Drag
        document.getElementById('dp-toggle-drag').addEventListener('click', () => {
            textDragEnabled = !textDragEnabled;
            introTextEl.classList.toggle('draggable', textDragEnabled);
            document.getElementById('dp-toggle-drag').textContent = textDragEnabled ? 'Disable Text Drag' : 'Enable Text Drag';
            console.log(`[Director] Text drag ${textDragEnabled ? 'ON' : 'OFF'}`);
        });

        // Text dragging
        introTextEl.addEventListener('mousedown', (e) => {
            if (!textDragEnabled) return;
            e.preventDefault();
            const rect = introTextEl.getBoundingClientRect();
            textDragOffset.x = e.clientX - rect.left;
            textDragOffset.y = e.clientY - rect.top;

            const onMove = (e) => {
                const newLeft = ((e.clientX - textDragOffset.x) / window.innerWidth) * 100;
                const newTop = ((e.clientY - textDragOffset.y) / window.innerHeight) * 100;
                introTextEl.style.left = newLeft + '%';
                introTextEl.style.top = newTop + '%';
                introTextEl.style.transform = 'none';
                updateDirectorPanel();
            };
            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });

        // Font size slider
        const fontSizeSlider = document.getElementById('dp-font-size');
        const fontSizeValue = document.getElementById('dp-font-size-value');
        fontSizeSlider.addEventListener('input', () => {
            const size = fontSizeSlider.value;
            introTextEl.style.fontSize = size + 'px';
            fontSizeValue.textContent = size + 'px';
        });

        // Max width slider
        const maxWidthSlider = document.getElementById('dp-max-width');
        const maxWidthValue = document.getElementById('dp-max-width-value');
        maxWidthSlider.addEventListener('input', () => {
            const width = maxWidthSlider.value;
            introTextEl.style.maxWidth = width + 'px';
            maxWidthValue.textContent = width + 'px';
        });

        // Copy Text CSS
        document.getElementById('dp-copy-text-css').addEventListener('click', () => {
            const rect = introTextEl.getBoundingClientRect();
            const topPct = ((rect.top / window.innerHeight) * 100).toFixed(1);
            const leftPct = ((rect.left / window.innerWidth) * 100).toFixed(1);
            const fontSize = introTextEl.style.fontSize || '30px';
            const maxWidth = introTextEl.style.maxWidth || '800px';
            const css = `top: ${topPct}%;\nleft: ${leftPct}%;\nfont-size: ${fontSize};\nmax-width: ${maxWidth};\ntransform: none;`;
            navigator.clipboard.writeText(css);
            console.log('[Director] Text CSS copied:\n' + css);
        });

        function updateZoomSlider() {
            zoomSlider.value = camera.zoom * 1000;
            document.getElementById('zoom-value').textContent = camera.zoom.toFixed(3);
        }

        // Mouse controls
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            if (!directorPanelActive && !freeCamera) return;  // Allow drag in director mode or free camera
            // Don't pan if clicking a speed limit node
            if (isSpeedLimitEditMode()) {
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                if (hitTestSpeedNode(screenX, screenY, camera)) return;
            }
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        const cellHoverInfo = document.getElementById('cell-hover-info');
        canvas.addEventListener('mousemove', (e) => {
            // Disabled for public deployment - mouse tracking causes frame drops
            return;
        });
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            cellHoverInfo.style.display = 'none';
        });
        canvas.addEventListener('wheel', (e) => {
            if (!directorPanelActive && !freeCamera) return;  // Allow zoom in director mode or free camera
            e.preventDefault();
            camera.zoomAt(e.deltaY > 0 ? 0.85 : 1.18, e.offsetX, e.offsetY);
            updateZoomSlider();
        });

        // ═══════════════════════════════════════════════════════════════════════════
        // R10 EASTER EGG — Raw sim mode (no director, free camera, local sim only)
        // ═══════════════════════════════════════════════════════════════════════════
        let _easterEggBuffer = '';
        const EASTER_EGG_CODE = 'R10';
        let _rawModeActive = false;

        async function activateRawMode() {
            if (_rawModeActive) return;
            _rawModeActive = true;
            console.log('[R10] Raw mode activated');

            // 1. Stop director completely
            director.stop();

            // 2. Enable free camera
            freeCamera = true;

            // 3. Hide director UI elements
            const skipBtn = document.getElementById('btn-skip');
            if (skipBtn) skipBtn.style.display = 'none';
            const telemetry = document.getElementById('telemetry-overlay');
            if (telemetry) telemetry.style.display = 'none';
            const narrative = document.querySelector('.narrative-overlay');
            if (narrative) narrative.style.display = 'none';

            // 4. Load and initialize local sim
            await loadLocalSim();

            // 5. Force zoom state to LOCAL_FIELD (bypasses macro layer)
            currentZoomState = ZoomState.LOCAL_FIELD;
            transitionProgress = 1;
            forceMacroRender = false;

            // 6. Snap camera to Reynosa frame (zoom > Z_LOCAL to stay in local mode)
            camera.centerWorld.x = -8491;
            camera.centerWorld.y = -5982;
            camera.zoom = 0.044488;

            // 7. Update UI indicators
            const stateEl = document.getElementById('zoom-state');
            if (stateEl) {
                stateEl.textContent = 'LOCAL_FIELD';
                stateEl.className = 'local';
            }
            const authEl = document.getElementById('authority-indicator');
            if (authEl) authEl.textContent = 'Authority: FIELD';

            // 8. Unpause and run
            time.paused = false;
            document.getElementById('btn-pause').textContent = 'Pause';

            // 9. Enable scenario buttons
            const btnInterserrana = document.getElementById('btn-interserrana');
            const btnTwinSpan = document.getElementById('btn-twin-span');
            const btnInovus = document.getElementById('btn-inovus');
            if (btnInterserrana) btnInterserrana.disabled = false;
            if (btnTwinSpan) btnTwinSpan.disabled = false;
            if (btnInovus) btnInovus.disabled = false;

            console.log('[R10] Local sim running. Free camera enabled. Spacebar=pause, D=debug, M=particle colors.');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // R10 easter egg sequence detection
            if (!_rawModeActive && e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
                _easterEggBuffer += e.key.toUpperCase();
                if (_easterEggBuffer.length > EASTER_EGG_CODE.length) {
                    _easterEggBuffer = _easterEggBuffer.slice(-EASTER_EGG_CODE.length);
                }
                if (_easterEggBuffer === EASTER_EGG_CODE) {
                    activateRawMode();
                    _easterEggBuffer = '';
                    return;
                }
            }

            // SPACEBAR: enabled after free camera unlock (skip button or director end)
            if (e.code === 'Space' && freeCamera) {
                e.preventDefault();
                time.paused = !time.paused;
                document.getElementById('btn-pause').textContent = time.paused ? 'Resume' : 'Pause';
                document.getElementById('replay-controls').style.display = time.paused ? 'block' : 'none';
                if (time.paused) updateReplayUI();
                console.log(`[SIM] ${time.paused ? 'Paused' : 'Resumed'} via spacebar`);
                return;
            }

            // 'r' = cycle speed modes: NORMAL → REAL-TIME (1:1) → 5x NORMAL
            if (e.key === 'r' || e.key === 'R') {
                const mode = time.cycleSpeedMode();
                const scale = time.timeScale;
                const scaleText = mode.mult === null
                    ? `1 sim-s/real-s (REAL-TIME)`
                    : `${scale.toFixed(0)} sim-s/real-s (${mode.name})`;
                document.getElementById('timescale-value').textContent = scaleText;
                console.log(`[SIM] Speed: ${mode.name} (${scale.toFixed(0)}x)`);
                return;
            }

            // 'b' = coordinate picker
            if (e.key === 'b' || e.key === 'B') {
                toggleCoordPicker();
                return;
            }

            // 'c' = copy collected coordinates OR speed limit polylines to clipboard
            if (e.key === 'c' || e.key === 'C') {
                // Speed limit edit mode takes priority
                if (isSpeedLimitEditMode()) {
                    const code = copySpeedLimitPolylines();
                    if (code) {
                        navigator.clipboard.writeText(code).then(() => {
                            console.log('[SPEED EDITOR] Polylines copied to clipboard');
                        });
                    }
                    return;
                }
                if (collectedCoords.length > 0) {
                    copyCoords();
                } else {
                    console.log('[CoordPicker] No coordinates to copy. Press B to pick points first.');
                }
                return;
            }

            // 'd' = physics X-ray overlay (freezes sim)
            if (e.key === 'd' || e.key === 'D') {
                togglePhysicsDebug();
                return;
            }

            // TAB = cycle debug layers (when debug active) OR toggle speed edit mode (when SPEED overlay)
            if (e.key === 'Tab') {
                e.preventDefault();
                if (showPhysicsDebug) {
                    cycleDebugLayer();
                    return;
                }
                // Toggle speed limit edit mode when in SPEED overlay mode
                if (getOverlayMode() === 'SPEED') {
                    toggleSpeedLimitEditMode();
                    return;
                }
            }

            // '`' = Toggle dark mode (canvas bg + macro particles + overlay)
            if (e.key === '`') {
                canvasBgDark = !canvasBgDark;
                if (macroParticles) macroParticles.toggleDarkMode();
                toggleDarkMode();
                console.log(`[Theme] Dark mode: ${canvasBgDark ? 'ON' : 'OFF'}`);
                return;
            }

            // 'e' = Director Mode panel
            if (e.key === 'e' || e.key === 'E') {
                toggleDirectorPanel();
                return;
            }

            if (!macroParticles) return;

            // 'x' = flickering lightshow tracers
            if (e.key === 'x' || e.key === 'X') {
                macroParticles.toggleDebugTracers();
            }
            // 'c' = stable diagnostic tracers
            if (e.key === 'c' || e.key === 'C') {
                macroParticles.toggleDebugTracers2();
            }
            // 'p' = Pharr highlight (Pharr particles black, others faint grey)
            if (e.key === 'p' || e.key === 'P') {
                macroParticles.togglePharrHighlight();
            }
            // 'o' = toggle particles on/off
            if (e.key === 'o' || e.key === 'O') {
                macroParticles.particlesVisible = !macroParticles.particlesVisible;
                console.log(`[MacroParticles] Particles visible: ${macroParticles.particlesVisible ? 'ON' : 'OFF'}`);
            }
            // 'm' = cycle particle color modes: OFF → STALL → SOURCE → OFF
            if (e.key === 'm' || e.key === 'M') {
                cycleParticleColorMode();
            }
            // 'c' = congestion heatmap (cyan cells showing congestion intensity)
            if (e.key === 'c' || e.key === 'C') {
                const on = toggleCongestionHeatmap();
                console.log(`[CONGESTION HEATMAP] ${on ? 'ON - cyan = congested cells' : 'OFF'}`);
            }
            // 'a' = ALTO - block bridge (test congestion shockwave)
            if (e.key === 'a' || e.key === 'A') {
                ReynosaEastOverlay.toggleBlockBridge();
            }
            // 'v' = View capture - capture current camera position for director script
            if (e.key === 'v' || e.key === 'V') {
                captureView();
            }
            // 't' = Cycle overlay mode (OFF → COMMUTER → SPEED)
            if (e.key === 't' || e.key === 'T') {
                cycleOverlayMode();
            }
        });

        // Coordinate picker click handler
        canvas.addEventListener('click', (e) => {
            if (!coordPickerActive) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = camera.screenToWorld(screenX, screenY);
            addCoordinate(world.x, world.y);
        });

        // Speed limit node drag handlers
        canvas.addEventListener('mousedown', (e) => {
            if (!isSpeedLimitEditMode()) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const hit = hitTestSpeedNode(screenX, screenY, camera);
            if (hit) {
                startDragSpeedNode(hit);
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDraggingSpeedNode()) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = camera.screenToWorld(screenX, screenY);
            dragSpeedNode(world.x, world.y);
        });

        canvas.addEventListener('mouseup', () => {
            if (isDraggingSpeedNode()) {
                endDragSpeedNode();
                canvas.style.cursor = isSpeedLimitEditMode() ? 'crosshair' : 'grab';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDraggingSpeedNode()) {
                endDragSpeedNode();
                canvas.style.cursor = isSpeedLimitEditMode() ? 'crosshair' : 'grab';
            }
        });

        // Double-click to insert new control point on nearest segment
        canvas.addEventListener('dblclick', (e) => {
            console.log('[DBLCLICK] edit mode:', isSpeedLimitEditMode());
            if (!isSpeedLimitEditMode()) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            console.log('[DBLCLICK] screen:', screenX, screenY);

            // Don't insert if clicking on existing node
            const hitNode = hitTestSpeedNode(screenX, screenY, camera);
            console.log('[DBLCLICK] hitNode:', hitNode);
            if (hitNode) return;

            const segment = findNearestSegment(screenX, screenY, camera, 50);  // increased from 20
            console.log('[DBLCLICK] segment:', segment);
            if (segment) {
                const world = camera.screenToWorld(screenX, screenY);
                insertSpeedNode(world.x, world.y, segment);
            }
        });

        // Right-click to delete a node
        canvas.addEventListener('contextmenu', (e) => {
            if (!isSpeedLimitEditMode()) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            const hit = hitTestSpeedNode(screenX, screenY, camera);
            if (hit) {
                e.preventDefault();
                deleteSpeedNode(hit);
            }
        });

        // Coordinate picker buttons
        document.getElementById('copy-coords-btn').addEventListener('click', copyCoords);
        document.getElementById('clear-coords-btn').addEventListener('click', clearCoords);

        // =====================================================================
        // RENDERERS
        // =====================================================================

        /**
         * Get segment weight: interpolated if dual-scenario, local map otherwise.
         */
        function getSegmentWeight(segmentId) {
            if (interserranaBundleLoaded && hasWeightMaps()) {
                return getInterpolatedWeight(segmentId, macroAlpha);
            }
            return segmentWeights.get(segmentId) || 0;
        }

        /**
         * Smooth color interpolation using HSL for perceptually uniform blending.
         * Goes from deep blue (low) → cyan → green → yellow → orange (high)
         */
        function weightToColor(weight) {
            // Clamp weight to [0, 1]
            const w = Math.max(0, Math.min(1, weight));

            // Use sqrt for perceptual scaling (like map_generator.py)
            const t = Math.sqrt(w);

            // HSL interpolation: hue goes from 220 (blue) → 180 (cyan) → 120 (green) → 60 (yellow) → 30 (orange)
            // Simplified: interpolate hue from 220 (blue) down to 30 (orange)
            const hue = 220 - t * 190;  // 220 → 30
            const sat = 70 + t * 20;     // 70% → 90% saturation
            const lit = 45 + t * 15;     // 45% → 60% lightness

            return `hsl(${hue}, ${sat}%, ${lit}%)`;
        }

        // Cache for sorted segments (recompute only when bundle changes)
        let _sortedSegmentsCache = null;
        let _sortedSegmentsCacheHash = null;

        function getSortedSegments() {
            const hash = `${bundleLoaded}_${macroAlpha.toFixed(3)}`;
            if (_sortedSegmentsCache && _sortedSegmentsCacheHash === hash) {
                return _sortedSegmentsCache;
            }

            const segments = getSegmentsInROI()
                .map(seg => ({ seg, weight: getSegmentWeight(seg.segment_id) }))
                .sort((a, b) => b.weight - a.weight)
                .map(({ seg }) => seg);
            const segmentsWithWeights = [];

            for (const seg of segments) {
                if (seg.points.length < 2) continue;
                const weight = getSegmentWeight(seg.segment_id);

                // Precompute bounding box for culling
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const pt of seg.points) {
                    if (pt.x < minX) minX = pt.x;
                    if (pt.x > maxX) maxX = pt.x;
                    if (pt.y < minY) minY = pt.y;
                    if (pt.y > maxY) maxY = pt.y;
                }

                segmentsWithWeights.push({ seg, weight, minX, maxX, minY, maxY });
            }

            // Sort by weight descending
            segmentsWithWeights.sort((a, b) => b.weight - a.weight);

            _sortedSegmentsCache = segmentsWithWeights;
            _sortedSegmentsCacheHash = hash;
            return segmentsWithWeights;
        }

        /**
         * MACRO_CIEN Renderer
         * Shows: Faint segment guides + black particle streams
         * Authority: CIEN
         *
         * Design: Motion alone communicates direction + magnitude
         *         No color encoding, no thickness variation
         *         Particles follow segment geometry
         */
        function renderMacroCien(ctx, camera, alpha = 1.0) {
            if (!bundleLoaded) return;

            ctx.globalAlpha = alpha;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Road network drawing disabled - was breaking rendering

            // Draw particles
            if (macroParticles) {
                const tDrawParticlesStart = performance.now();
                macroParticles.draw(ctx, camera);
                const tDrawParticlesEnd = performance.now();
                // Throttle timing logs (console logging is expensive)
                if (!renderMacroCien._timingFrames) {
                    renderMacroCien._timingFrames = 0;
                    renderMacroCien._timingPartAccum = 0;
                }
                renderMacroCien._timingFrames++;
                renderMacroCien._timingPartAccum += (tDrawParticlesEnd - tDrawParticlesStart);
                if (renderMacroCien._timingFrames >= 600) {
                    console.log(
                        `[TIMING] particlesDraw=${(renderMacroCien._timingPartAccum / 600).toFixed(2)}ms`
                    );
                    renderMacroCien._timingFrames = 0;
                    renderMacroCien._timingPartAccum = 0;
                }

            }

            // Orientation labels (sources/sinks) - on top of particles
            renderOrientationLabels(ctx, camera);

            // Framing square
            renderFramingSquare(ctx, camera);

            // Interserrana highlight box
            renderInterserranaBox(ctx, camera);

            // Layer transition indicator
            renderLayerTransitionSquare(ctx, camera);

            // Lot highlight overlay
            renderLotHighlight(ctx, camera);

            // Queue time series chart (UI overlay - screen space)
            if (queueTimeSeries) {
                queueTimeSeries.draw(ctx, canvas.width, canvas.height);
            }

            ctx.globalAlpha = alpha;
            ctx.globalAlpha = 1.0;
        }

        /**
         * LOCAL_FIELD Renderer
         * Shows: Density field heatmap, local roads
         * Authority: FIELD
         */
        function renderLocalField(ctx, camera, alpha = 1.0) {
            if (!bundleLoaded || !fieldAttached) return;

            ctx.globalAlpha = alpha;

            // Overlay handles all rendering: lots, roads (on top), particles
            ReynosaEastOverlay.draw(ctx, camera);

            // Lot highlight overlay (triggered by Director)
            renderLotHighlight(ctx, camera);

            ctx.globalAlpha = 1.0;
        }

        /**
         * Transition renderer - visual interpolation only
         * No physics computation during transitions
         */
        function renderTransition(ctx, camera, progress, direction) {
            // direction: 'in' = macro->local, 'out' = local->macro
            const macroAlpha = direction === 'in' ? (1 - progress) : progress;
            const localAlpha = direction === 'in' ? progress : (1 - progress);

            // Render both with appropriate alpha
            if (macroAlpha > 0.01) {
                renderMacroCien(ctx, camera, macroAlpha);
            }
            if (localAlpha > 0.01 && fieldInitialized) {
                renderLocalField(ctx, camera, localAlpha);
            }
        }

        // =====================================================================
        // PERFORMANCE PROBE (MACRO)
        // =====================================================================

        let _perfFrames = 0;
        let _perfAccum = 0;
        let _perfLast = performance.now();

        function logMacroPerf(startMs, endMs) {
            _perfAccum += (endMs - startMs);
            _perfFrames++;
            if (_perfFrames === 60) {
                console.log(`[PERF] macro avg frame = ${(_perfAccum / 60).toFixed(2)} ms`);
                _perfFrames = 0;
                _perfAccum = 0;
            }
        }

        // =====================================================================
        // MAIN FRAME LOOP
        // =====================================================================

        let lastFrameTime = performance.now();
        let tabWasHidden = false;

        // Auto-pause when tab is hidden to prevent freeze on return
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                tabWasHidden = true;
                console.log('[TAB] Hidden - sim will skip accumulated time on return');
            } else if (tabWasHidden) {
                // Reset lastFrameTime to prevent huge dt catchup
                lastFrameTime = performance.now();
                tabWasHidden = false;
                console.log('[TAB] Visible - reset frame timer');
            }
        });

        // Frame timing instrumentation
        const _frameTiming = {
            frameCount: 0,
            accumDt: 0,
            accumZoomState: 0,
            accumTimeTick: 0,
            accumAlphaRamp: 0,
            accumWeightsUpdate: 0,
            accumParticleUpdate: 0,
            accumFieldPhysics: 0,
            accumClear: 0,
            accumRender: 0,
            accumCoordMarkers: 0,
            accumPhysicsDebug: 0,
            accumUpdateUI: 0,
            accumTotal: 0,
            accumGap: 0,  // Time between frames (outside frame work)
            lastFrameEnd: 0,
            lastLogTime: 0,
        };

        async function frame(now) {
            const tFrameStart = performance.now();

            // Measure gap: time from previous frame END to this frame START
            if (_frameTiming.lastFrameEnd > 0) {
                _frameTiming.accumGap += (tFrameStart - _frameTiming.lastFrameEnd);
            }

            const dt = now - lastFrameTime;
            lastFrameTime = now;

            // 1. Update zoom state machine
            const t1 = performance.now();
            const stateChanged = updateZoomState(camera.zoom, now);
            const t2 = performance.now();

            // 2. Tick time (always, for UI display)
            const prevHour = time.currentHour;
            time.tick(dt);

            // 2b. Tick director (camera animations)
            director.tick(dt, now);
            if (director.isPlaying()) {
                updateZoomSlider();
                // Advance macro month clock
                if (macroMonthActive) {
                    macroMonthElapsedMs += dt;
                    updateMacroMonthClock();
                }
            }
            const t3 = performance.now();

            // 3. Update hour display
            const h = time.currentHour;
            hourSlider.value = h;
            hourValue.textContent = h.toString().padStart(2, '0') + ':00';

            // Day wrap diagnostic
            if (prevHour === 23 && h === 0) {
                const dayEndTime = performance.now();
                if (window._dayStartTime) {
                    const dayDurationSec = (dayEndTime - window._dayStartTime) / 1000;
                    console.log(`[TIME] Day completed in ${dayDurationSec.toFixed(1)}s (expected: 75s)`);
                }
                window._dayStartTime = dayEndTime;
            }
            if (!window._dayStartTime && h === 0) {
                window._dayStartTime = performance.now();
            }

            // 4. Update MACRO α (smooth ramp toward target)
            let weightsUpdated = false;
            const t4 = performance.now();
            if (macroAlpha !== macroTargetAlpha && macroRampStartTime !== null) {
                const elapsed = now - macroRampStartTime;
                const t = Math.min(1, elapsed / MACRO_RAMP_DURATION);
                // Smoothstep easing
                const eased = t * t * (3 - 2 * t);
                macroAlpha = macroRampStartAlpha + (macroTargetAlpha - macroRampStartAlpha) * eased;

                if (t >= 1) {
                    macroAlpha = macroTargetAlpha;
                    macroRampStartTime = null;
                }

                // Update macro particle weights (smooth interpolation)
                if (macroParticles && interserranaBundleLoaded) {
                    const tWeights0 = performance.now();
                    macroParticles.updateWeights(segId => getSegmentWeight(segId));
                    // Sync scenario alpha so new particles use correct POE distribution
                    macroParticles.setScenarioAlpha(macroAlpha);
                    // Also sync to FIELD overlay for injection interpolation
                    setScenarioAlpha(macroAlpha);
                    const tWeights1 = performance.now();
                    _frameTiming.accumWeightsUpdate += (tWeights1 - tWeights0);
                    weightsUpdated = true;
                }
            }

            // 4b. Update TWIN SPAN α (smooth ramp, independent of Interserrana)
            if (twinSpanAlpha !== twinSpanTargetAlpha && twinSpanRampStartTime !== null) {
                const elapsed = now - twinSpanRampStartTime;
                const t = Math.min(1, elapsed / TWIN_SPAN_RAMP_DURATION);
                const eased = t * t * (3 - 2 * t);
                twinSpanAlpha = twinSpanRampStartAlpha + (twinSpanTargetAlpha - twinSpanRampStartAlpha) * eased;

                if (t >= 1) {
                    twinSpanAlpha = twinSpanTargetAlpha;
                    twinSpanRampStartTime = null;
                }

                updateTwinSpanState(twinSpanAlpha);
            }
            const t5 = performance.now();

            // 5. Update macro particles
            const t6 = performance.now();
            if (macroParticles) {
                macroParticles.update(dt / 1000, camera);  // dt in seconds
            }
            const t7 = performance.now();

            // 6. Run physics ONLY if FIELD has authority
            const t8 = performance.now();
            if (currentZoomState === ZoomState.LOCAL_FIELD && fieldAttached) {
                const realDeltaSeconds = dt / 1000;
                await ReynosaEastOverlay.onFrame(camera, time, realDeltaSeconds);
            }
            const t9 = performance.now();

            // 7. Clear canvas
            const t10 = performance.now();
            ctx.fillStyle = canvasBgDark ? '#000000' : '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Show WebGL overlay in all view modes (both MACRO and LOCAL use WebGL particles)
            // Each particle system clears the canvas when not drawing
            glCanvas.style.display = 'block';
            const t11 = performance.now();

            // Update fade-in alpha
            if (fadeInStartTime !== null && fadeInAlpha < 1) {
                const elapsed = performance.now() - fadeInStartTime;
                fadeInAlpha = Math.min(1, elapsed / FADE_IN_DURATION);
            }

            // 8. Render based on state (or force macro if Director override active)
            const t12 = performance.now();
            if (forceMacroRender) {
                // Director override - show macro layer regardless of zoom state
                const t0 = performance.now();
                renderMacroCien(ctx, camera, 1.0);
                const t1 = performance.now();
                logMacroPerf(t0, t1);
            } else {
                switch (currentZoomState) {
                    case ZoomState.MACRO_CIEN: {
                        const t0 = performance.now();
                        renderMacroCien(ctx, camera, fadeInAlpha);
                        const t1 = performance.now();
                        logMacroPerf(t0, t1);
                        break;
                    }

                    case ZoomState.TRANSITION_IN:
                        renderTransition(ctx, camera, transitionProgress, 'in');
                        break;

                    case ZoomState.LOCAL_FIELD:
                        renderLocalField(ctx, camera);
                        break;

                    case ZoomState.TRANSITION_OUT:
                        renderTransition(ctx, camera, transitionProgress, 'out');
                        break;
                }
            }
            const t13 = performance.now();

            // 8b. Draw POE Bleed Visualization (on top of map, below UI)
            if (poeNodeLayer) {
                poeNodeLayer.draw(ctx, camera, now);
            }
            const t13b = performance.now();

            // 9. Draw coordinate picker markers on top
            drawCoordMarkers(ctx, camera);
            const t14 = performance.now();

            // 10. Draw physics debug overlay
            drawPhysicsDebug(ctx, camera);
            const t15 = performance.now();

            // 11. Update UI
            updateUI();
            updateDirectorPanel();
            const t16 = performance.now();

            // Accumulate timing
            _frameTiming.frameCount++;
            _frameTiming.accumDt += dt;
            _frameTiming.accumZoomState += (t2 - t1);
            _frameTiming.accumTimeTick += (t3 - t2);
            _frameTiming.accumAlphaRamp += (t5 - t4);
            _frameTiming.accumParticleUpdate += (t7 - t6);
            _frameTiming.accumFieldPhysics += (t9 - t8);
            _frameTiming.accumClear += (t11 - t10);
            _frameTiming.accumRender += (t13 - t12);
            _frameTiming.accumCoordMarkers += (t14 - t13);
            _frameTiming.accumPhysicsDebug += (t15 - t14);
            _frameTiming.accumUpdateUI += (t16 - t15);
            _frameTiming.accumTotal += (t16 - tFrameStart);

            // Mark frame end for gap measurement
            _frameTiming.lastFrameEnd = performance.now();

            // Log every 2 seconds
            if (now - _frameTiming.lastLogTime > 2000) {
                const n = _frameTiming.frameCount || 1;
                const avgDt = _frameTiming.accumDt / n;
                const avgGap = _frameTiming.accumGap / n;
                const avgTotal = _frameTiming.accumTotal / n;
                const fps = 1000 / avgDt;
                console.log(`[FRAME INSTRUMENTATION] frames=${n} avgDt=${avgDt.toFixed(1)}ms (${fps.toFixed(1)}fps)`);
                console.log(`  TOTAL=${avgTotal.toFixed(2)}ms GAP=${avgGap.toFixed(2)}ms (work+gap=${(avgTotal + avgGap).toFixed(2)}ms)`);
                console.log(`  zoomState=${(_frameTiming.accumZoomState / n).toFixed(2)}ms timeTick=${(_frameTiming.accumTimeTick / n).toFixed(2)}ms alphaRamp=${(_frameTiming.accumAlphaRamp / n).toFixed(2)}ms`);
                console.log(`  weightsUpdate=${(_frameTiming.accumWeightsUpdate / n).toFixed(2)}ms particleUpdate=${(_frameTiming.accumParticleUpdate / n).toFixed(2)}ms fieldPhysics=${(_frameTiming.accumFieldPhysics / n).toFixed(2)}ms`);
                console.log(`  clear=${(_frameTiming.accumClear / n).toFixed(2)}ms render=${(_frameTiming.accumRender / n).toFixed(2)}ms coordMarkers=${(_frameTiming.accumCoordMarkers / n).toFixed(2)}ms`);
                console.log(`  physicsDebug=${(_frameTiming.accumPhysicsDebug / n).toFixed(2)}ms updateUI=${(_frameTiming.accumUpdateUI / n).toFixed(2)}ms`);

                // Reset accumulators
                _frameTiming.frameCount = 0;
                _frameTiming.accumDt = 0;
                _frameTiming.accumGap = 0;
                _frameTiming.accumZoomState = 0;
                _frameTiming.accumTimeTick = 0;
                _frameTiming.accumAlphaRamp = 0;
                _frameTiming.accumWeightsUpdate = 0;
                _frameTiming.accumParticleUpdate = 0;
                _frameTiming.accumFieldPhysics = 0;
                _frameTiming.accumClear = 0;
                _frameTiming.accumRender = 0;
                _frameTiming.accumCoordMarkers = 0;
                _frameTiming.accumPhysicsDebug = 0;
                _frameTiming.accumUpdateUI = 0;
                _frameTiming.accumTotal = 0;
                _frameTiming.lastLogTime = now;
            }

            requestAnimationFrame(frame);
        }

        // Cache DOM elements once (getElementById is expensive)
        const _uiCache = {
            stateEl: null,
            authEl: null,
            inflowEl: null,
            capEl: null,
            segmentsEl: null,
            alphaEl: null,
            throughputEl: null,
            backlogEl: null,
            totalEl: null,
            lastUpdate: 0,
            lastState: null,
            lastHour: -1,
        };

        function initUICache() {
            _uiCache.stateEl = document.getElementById('zoom-state');
            _uiCache.authEl = document.getElementById('authority-indicator');
            _uiCache.inflowEl = document.getElementById('m-inflow');
            _uiCache.capEl = document.getElementById('m-cap');
            _uiCache.segmentsEl = document.getElementById('m-segments');
            _uiCache.alphaEl = document.getElementById('m-alpha');
            _uiCache.throughputEl = document.getElementById('m-throughput');
            _uiCache.backlogEl = document.getElementById('m-backlog');
            _uiCache.totalEl = document.getElementById('m-total');
        }

        // Tipping Text Helper (Spec §8: Single-line, no numbers, no explanations)
        function showTippingText(poeKey, displayName) {
            const el = document.getElementById('tipping-text');
            if (el) {
                // Spec §8: "{name} is losing traffic under congestion."
                el.textContent = `${displayName} is losing traffic under congestion.`;
                el.style.opacity = '1';
                // Auto-fade after 4s (spec: "a few seconds")
                setTimeout(() => {
                    el.style.opacity = '0';
                }, 4000);
            }
        }

        function updateUI() {
            // Throttle UI updates to every 200ms (5 fps for UI is plenty)
            const now = performance.now();
            if (now - _uiCache.lastUpdate < 200) return;
            _uiCache.lastUpdate = now;

            // Init cache on first call
            if (!_uiCache.stateEl) initUICache();

            // Zoom state indicator (only update if changed)
            if (_uiCache.lastState !== currentZoomState) {
                _uiCache.lastS = ZoomState;
                switch (currentZoomState) {
                    case ZoomState.MACRO_CIEN:
                        _uiCache.stateEl.className = 'macro';
                        _uiCache.stateEl.textContent = 'MACRO_CIEN';
                        _uiCache.authEl.textContent = 'Authority: CIEN (equilibrium)';
                        _uiCache.authEl.style.color = '#6af';
                        break;
                    case ZoomState.TRANSITION_IN:
                        _uiCache.stateEl.className = 'transition';
                        _uiCache.authEl.textContent = 'Authority: NONE (visual only)';
                        _uiCache.authEl.style.color = '#ff0';
                        break;
                    case ZoomState.LOCAL_FIELD:
                        _uiCache.stateEl.className = 'local';
                        _uiCache.stateEl.textContent = 'LOCAL_FIELD';
                        _uiCache.authEl.textContent = 'Authority: FIELD (evolving)';
                        _uiCache.authEl.style.color = '#6f6';
                        break;
                    case ZoomState.TRANSITION_OUT:
                        _uiCache.stateEl.className = 'transition';
                        _uiCache.authEl.textContent = 'Authority: NONE (visual only)';
                        _uiCache.authEl.style.color = '#ff0';
                        break;
                }
            }

            // Update transition progress text if in transition
            if (currentZoomState === ZoomState.TRANSITION_IN || currentZoomState === ZoomState.TRANSITION_OUT) {
                _uiCache.stateEl.textContent = `${currentZoomState === ZoomState.TRANSITION_IN ? 'TRANSITION_IN' : 'TRANSITION_OUT'} (${(transitionProgress * 100).toFixed(0)}%)`;
            }

            // Metrics (only update if hour changed or every 200ms)
            if (!bundleLoaded) return;

            const h = time.currentHour;
            if (_uiCache.lastHour !== h) {
                _uiCache.lastHour = h;
                const inflow = getHourlyInflow(h);
                const cap = getHourlyCapacity(h);
                // Real daily values - no scaling
                _uiCache.inflowEl.textContent = (inflow.total_kg / 1000).toFixed(0) + ' t/hr';
                _uiCache.capEl.textContent = (cap / 1000).toFixed(0) + ' t/hr';
            }

            // Segment count (expensive - only update every 200ms via throttle)
            // Skip getSegmentsInROI call - it's too expensive and segment count rarely changes
            // _uiCache.segmentsEl.textContent = getSegmentsInROI().length;

            // Scenario α
            if (interserranaBundleLoaded) {
                _uiCache.alphaEl.textContent = macroAlpha.toFixed(2);
                _uiCache.alphaEl.style.color = macroAlpha > 0 ? '#fa0' : '#0f0';
            }

            // FIELD metrics only in LOCAL_FIELD
            if (currentZoomState === ZoomState.LOCAL_FIELD && fieldAttached) {
                const m = getMetrics();
                _uiCache.throughputEl.textContent = (m.throughput_kg_per_hr / 1000).toFixed(0) + ' t/hr';
                _uiCache.backlogEl.textContent = (m.backlog_near_pharr / 1000).toFixed(1) + ' t';
                _uiCache.totalEl.textContent = (m.total / 1000).toFixed(1) + ' t';
            } else if (_uiCache.throughputEl.textContent !== '--') {
                _uiCache.throughputEl.textContent = '--';
                _uiCache.backlogEl.textContent = '--';
                _uiCache.totalEl.textContent = '--';
            }
        }

        // =====================================================================
        // START
        // =====================================================================

        // Start render loop immediately (shows intro text while bundle loads)
        updateZoomSlider();
        requestAnimationFrame(frame);

        // Load bundle in background - will be ready before particles needed
        // (~25+ seconds of text/dimension display before particles start)
        syncBundleVariantButtons(currentBundleSuffix);  // Initialize button text
        loadBundleFromFile().then(() => {
            console.log('[INIT] Bundle loaded in background');
            // All bundles (including LAYER_A) now loaded in loadBundleFromFile()
            syncBundleVariantButtons(currentBundleSuffix);
        });

        console.log('='.repeat(60));
        console.log('CIEN/FIELD Viewer initialized');
        console.log('Zoom states: MACRO_CIEN -> TRANSITION_IN -> LOCAL_FIELD -> TRANSITION_OUT');
        console.log('Z_MACRO:', Z_MACRO, ' Z_LOCAL:', Z_LOCAL);
        console.log('='.repeat(60));

        // Expose debug functions to console
        window.viewerDebug = {
            forceRebuildPhiBase,
            isPhiRebuilding,
            captureView,
            getSourceShares,
            printSourceShares,
            get capturedViews() { return capturedViews; },
            exportViews: () => {
                const beats = capturedViews.map(v => `{ x: ${v.x}, y: ${v.y}, zoom: ${v.zoom} }`);
                const output = `[\n  ${beats.join(',\n  ')}\n]`;
                console.log('[VIEW] All captured beats:');
                console.log(output);
                navigator.clipboard.writeText(output);
                return output;
            },
            clearViews: () => { capturedViews = []; console.log('[VIEW] Cleared'); },
        };
        console.log('[DEBUG] window.viewerDebug available: printSourceShares(), getSourceShares()');
        console.log('[VIEW] Press V to capture camera position. viewerDebug.exportViews() to get all.');
    </script>
</body>

</html>